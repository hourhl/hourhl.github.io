<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AFL++的安装和基本使用</title>
    <url>/2024/09/07/AFL-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="AFL"><a href="#AFL" class="headerlink" title="AFL++"></a>AFL++</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AFL++是在AFL基础上进行改进的模糊测试工具，其<a href="https://github.com/AFLplusplus/AFLplusplus">源码</a>可以从github上得到。AFL++会将测试用例进行变异并作为输入交给目标程序，当这个测试用例能够触发新的路径时，就会被保存并进一步变异测试。</p>
<h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><p>AFL++的安装可以通过docker安装，也可以通过源码安装，本实验通过源码安装<br>根据<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/INSTALL.md">readme</a>进行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统版本 Ubuntu20</span></span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y build-essential python3-dev automake cmake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools cargo libgtk-3-dev</span><br><span class="line">sudo apt-get install -y lld-14 llvm-14 llvm-14-dev clang-14 || sudo apt-get install -y lld llvm llvm-dev clang</span><br><span class="line">sudo apt-get install -y gcc-$(gcc --version|head -n1|sed &#x27;s/\..*//&#x27;|sed &#x27;s/.* //&#x27;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed &#x27;s/\..*//&#x27;|sed &#x27;s/.* //&#x27;)-dev</span><br><span class="line">sudo apt-get install -y ninja-build # for QEMU mode</span><br><span class="line">sudo apt-get install -y cpio libcapstone-dev # for Nyx mode</span><br><span class="line">sudo apt-get install -y wget curl # for Frida mode</span><br><span class="line">sudo apt-get install python3-pip # for Unicorn mode</span><br><span class="line">git clone https://github.com/AFLplusplus/AFLplusplus</span><br><span class="line">cd AFLplusplus</span><br><span class="line">make distrib</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>利用afl-training中的<a href="https://github.com/mykter/afl-training/tree/main/quickstart">vulnerable.c</a>来进行实验</p>
<h3 id="有源码"><a href="#有源码" class="headerlink" title="有源码"></a>有源码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CC=afl-clang-fast AFL_HARDEN=1 make</span><br><span class="line">echo core | sudo tee /proc/sys/kernel/core_pattern</span><br><span class="line">afl-fuzz -i inputs -o out ./vulnerable</span><br></pre></td></tr></table></figure>
<p>可以看到afl++能够成功运行这个目标程序，并且能够触发崩溃<br><img src="./image1.png" width="60%" height="60%" /></p>
<h3 id="无源码"><a href="#无源码" class="headerlink" title="无源码"></a>无源码</h3><h4 id="测试整个程序"><a href="#测试整个程序" class="headerlink" title="测试整个程序"></a>测试整个程序</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o vul vulnerable.c </span><br><span class="line">echo core | sudo tee /proc/sys/kernel/core_pattern</span><br><span class="line">afl-fuzz -Q -i inputs -o out ./vul</span><br></pre></td></tr></table></figure>
<p>由于这个程序没有利用afl++编译插桩过，因此需要利用qemu模式，即运行afl++的时候需要加上参数-Q<br><img src="./image2.png" width="60%" height="60%" /></p>
<h4 id="测试某个函数"><a href="#测试某个函数" class="headerlink" title="测试某个函数"></a>测试某个函数</h4><p><a href="https://github.com/mykter/afl-training/blob/main/quickstart/vulnerable.c">vulnerable.c</a></p>
<p>假设要fuzz的目标函数是<strong>process</strong>，查阅AFL++的文档，了解到可以用AFL++的<a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.persistent.md">persistent mode</a>。文档中提到，使用该模式需要确认目标函数的地址，并且编写<a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/utils/qemu_persistent_hook">persistent hook</a>来传入对应的参数。因此实验流程如下</p>
<ol>
<li>确认目标函数在程序中的偏移地址</li>
</ol>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确定process的地址</span></span><br><span class="line">nm vul | grep &quot;T process&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">值为00000000000012c9</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AFL++在qemu模式的情况下进行fuzz的时候，如果程序启用了PIE,需要加上基地址0x4000000000</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以使用 checksec --file=vul 来确认是否启用了PIE</span></span><br><span class="line">export AFL_QEMU_PERSISTENT_ADDR=0x40000012c9</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>参照<a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/utils/qemu_persistent_hook">样例</a>编写persistent hook</li>
</ol>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/xu/lab-tools/git-lab/aflplusplus/AFLplusplus/qemu_mode/qemuafl/qemuafl/api.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> g2h(x) ((void *)((unsigned long)(x) + guest_base))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> h2g(x) ((uint64_t)(x) - guest_base)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">afl_persistent_hook</span><span class="params">(<span class="keyword">struct</span> x86_64_regs *regs, <span class="type">uint64_t</span> guest_base,</span></span><br><span class="line"><span class="params">                       <span class="type">uint8_t</span> *input_buf, <span class="type">uint32_t</span> input_buf_len)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In this example the register RDI is pointing to the memory location</span></span><br><span class="line">  <span class="comment">// of the target buffer, and the length of the input is in RSI.</span></span><br><span class="line">  <span class="comment">// This can be seen with a debugger, e.g. gdb (and &quot;disass main&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Placing input into 0x%lx\n&quot;</span>, regs-&gt;rdi);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length of input_buf is %d\n&quot;</span>,input_buf_len);</span><br><span class="line">  <span class="built_in">memcpy</span>(g2h(regs-&gt;rdi), input_buf, input_buf_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> g2h</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> h2g</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">afl_persistent_hook_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1 for shared memory input (faster), 0 for normal input (you have to use</span></span><br><span class="line">  <span class="comment">// read(), input_buf will be NULL)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行AFL++来进行模糊测试</li>
</ol>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared read_into_rdi.c -o read_into_rdi.so</span><br><span class="line">export AFL_QEMU_PERSISTENT_HOOK=./read_into_rdi.so</span><br><span class="line">export AFL_QEMU_PERSISTENT_GPR=1</span><br><span class="line">export AFL_QEMU_PERSISTENT_MEM=1</span><br><span class="line">export AFL_QEMU_PERSISTENT_EXITS=1</span><br><span class="line"></span><br><span class="line">mkdir outputs</span><br><span class="line">export AFL_NO_FORKSRV=1</span><br><span class="line">AFL_DEBUG=1 afl-fuzz -Q -i inputs -o outputs ./vul</span><br></pre></td></tr></table></figure>

<p>  可以看到afl++能够成功运行程序并且触发崩溃<br>  <img src="./image3.png" width="60%" height="60%" /></p>
<blockquote>
<p>由于无法从AFL++的界面中直观地看出是否进入persistent mode，因此可以通过在vulnerable.c中添加一些输入来确定是否达到我们的预期，比如在main函数中添加<code>printf(&quot;function : main\n&quot;)</code>，在process函数中添加<code>printf(&quot;function : process\n&quot;)</code>，然后在运行afl++的指令前加上<code>AFL_DEBUG=1</code>，如果看到main的输出只有一次，process函数反复输出，说明程序的运行达到了我们的预期。</p>
</blockquote>
]]></content>
      <categories>
        <category>模糊测试</category>
      </categories>
      <tags>
        <tag>模糊测试</tag>
        <tag>AFL++</tag>
      </tags>
  </entry>
  <entry>
    <title>Gnutls源码安装小记</title>
    <url>/2024/08/20/Gnutls%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="源码安装Gnutls"><a href="#源码安装Gnutls" class="headerlink" title="源码安装Gnutls"></a>源码安装Gnutls</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>根据Gnutls仓库的<a href="https://gitlab.com/gnutls/gnutls">readme</a>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">apt-get install -y dash git-core autoconf libtool gettext autopoint</span><br><span class="line">apt-get install -y automake python3 nettle-dev libp11-kit-dev libtspi-dev libunistring-dev</span><br><span class="line">apt-get install -y libtasn1-bin libtasn1-6-dev libidn2-0-dev gawk gperf</span><br><span class="line">apt-get install -y libtss2-dev libunbound-dev dns-root-data bison gtk-doc-tools</span><br><span class="line">apt-get install -y texinfo texlive texlive-plain-generic texlive-extra-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译安装</span></span><br><span class="line">./bootstrap</span><br><span class="line">./configure --with-included-libtasn1 --with-included-unistring</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><ol>
<li><p><code>Libnettle x.x was not found</code> (x是一个版本的数字，比如Libnettle 3.6 was not found)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装nettle（源码安装或者sudo apt安装）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到pkgconfig文件夹，更新PKG_CONFIG_PATH路径，例如</span></span><br><span class="line">export PKG_CONFIG_PATH=&quot;/usr/local/lib64/pkgconfig:$PKG_CONFIG_PATH&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新编译</span> </span><br><span class="line">./configure --with-included-libtasn1 --with-included-unistring</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nettlex.so not found</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到nettlex.so的地址，手动设置共享库地址</span> </span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib64:$LD_LIBRARY_PATH</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新缓存</span></span><br><span class="line">echo &quot;/usr/local/lib64&quot; | sudo tee /etc/ld.so.conf.d/local-lib.conf</span><br><span class="line">sudo ldconfig</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新编译</span></span><br><span class="line">sudo make clean</span><br><span class="line">./configure --with-included-libtasn1 --with-included-unistring</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>./cha-config.texi:1: node System-wide configuration of the library&#39; lacks menu item for Enabling/Disabling RSAES-PKCS1-v1_5&#39; despite being its Up target</code> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make clean</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用文档生成</span></span><br><span class="line">./configure --with-included-libtasn1 --with-included-unistring --disable-doc</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>E: 无法定位软件包 texlive-plain-generic</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装其他类似的安装包</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install texlive-base</span><br></pre></td></tr></table></figure></li>
<li><p><code>libev4 was not found.</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libev4 libev-dev</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>Gnutls</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>StrongSwan部署小记</title>
    <url>/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="虚拟机搭建strongswan"><a href="#虚拟机搭建strongswan" class="headerlink" title="虚拟机搭建strongswan"></a>虚拟机搭建strongswan</h1><p>注：仅作测试用，故服务端和客户端分别安装在了同一网段下的两台Ubuntu上。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ul>
<li><p>操作系统</p>
<!-- ![image-20240816074401529](E:\lab\IPsec.assets\image-20240816074401529.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image1.png" class="" title="image1">
</li>
<li><p>配置环境</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libgmp-dev libssl-dev libcurl4-openssl-dev libsystemd-dev libjson-c-dev make gcc pkg-config libsystemd-dev</span><br></pre></td></tr></table></figure>

<ul>
<li><p>安装过程</p>
<ul>
<li><p>下载源码并编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.strongswan.org/strongswan-5.8.3.tar.gz</span><br><span class="line">tar xzf strongswan-5.8.3.tar.gz</span><br><span class="line">cd strongswan-5.8.3</span><br><span class="line">./configure --prefix=/usr --sysconfdir=/etc --enable-eap-identity --enable-eap-md5 --enable-eap-mschapv2 --enable-eap-tls --enable-eap-ttls --enable-eap-peap --enable-eap-tnc --enable-eap-dynamic --enable-eap-radius --enable-xauth-eap --enable-xauth-pam  --enable-dhcp  --enable-openssl  --enable-addrblock --enable-unity --enable-certexpire --enable-radattr --enable-swanctl --enable-openssl --disable-gmp --enable-systemd</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>安装成功</p>
<!-- ![image-20240816080528752](E:\lab\IPsec.assets\image-20240816080528752.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image2.png" class="" title="image2">
</li>
<li><p>生成CA证书和服务器证书</p>
<p>创建服务器证书时，–dn中的CN要填写本机的ip，–san同理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir genPem</span><br><span class="line">cd genPem</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建CA密钥</span></span><br><span class="line">ipsec pki --gen --outform pem &gt; ca-key.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建CA证书</span></span><br><span class="line">ipsec pki --self --in ca-key.pem --dn &quot;C=CN, O=My VPN, CN=My VPN CA&quot; --ca --outform pem &gt; ca-cert.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建服务器密钥</span></span><br><span class="line">ipsec pki --gen --outform pem &gt; server-key.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建服务器证书</span></span><br><span class="line">ipsec pki --pub --in server-key.pem | ipsec pki --issue --cacert ca-cert.pem --cakey ca-key.pem --dn &quot;C=CN, O=My VPN, CN=serverIp&quot; --san=&quot;serverIp&quot; --flag serverAuth --outform pem &gt; server-cert.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将证书和密钥放到正确的位置</span></span><br><span class="line">sudo cp ca-cert.pem /etc/ipsec.d/cacerts/</span><br><span class="line">sudo cp server-cert.pem /etc/ipsec.d/certs/</span><br><span class="line">sudo cp server-key.pem /etc/ipsec.d/private/</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置&#x2F;etc&#x2F;ipsec.secrets（这个文件似乎可有可无，稳妥起见还是加上吧）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">: RSA &quot;server-key.pem&quot;</span><br><span class="line">test : EAP &quot;test&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置&#x2F;etc&#x2F;swanctl&#x2F;conf.d&#x2F;192.168.139.129.conf（注意：此处的文件名为本机的ip.conf）</p>
<p>下面的配置文件中有文字注释的部分需要修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">    ikev2-eap-mschapv2 &#123;</span><br><span class="line">        version = 2</span><br><span class="line">        unique = never</span><br><span class="line">        proposals = aes256-sha1-modp1024</span><br><span class="line">        # proposals = aes256-sha1-modp1024, aes128-sha1-modp1024, 3des-sha1-modp1024</span><br><span class="line">        # proposals = aes256-sha256-prfsha256-modp2048, aes256gcm16-prfsha384-modp1024, default</span><br><span class="line">        rekey_time = 0s</span><br><span class="line">        fragmentation = yes</span><br><span class="line">        dpd_delay = 30s</span><br><span class="line">        send_cert = always</span><br><span class="line">        local_addrs = %any</span><br><span class="line">        local &#123;</span><br><span class="line">            certs = server-cert.pem</span><br><span class="line">            # 服务器ip</span><br><span class="line">            id = 192.168.139.129</span><br><span class="line">        &#125;</span><br><span class="line">        remote &#123;</span><br><span class="line">            auth = eap-mschapv2</span><br><span class="line">            eap_id = %any</span><br><span class="line">            # request_virtual_ip = no</span><br><span class="line">        &#125;</span><br><span class="line">        children &#123;</span><br><span class="line">            ikev2-eap-mschapv2 &#123;</span><br><span class="line">                local_ts = 0.0.0.0/0,::/0</span><br><span class="line">                remote_ts = 0.0.0.0/0</span><br><span class="line">                rekey_time = 0s</span><br><span class="line">                dpd_action = clear</span><br><span class="line">                esp_proposals = aes256-sha256, aes128-sha1, default</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secrets &#123;</span><br><span class="line">    private-www &#123;</span><br><span class="line">        file = server-key.pem</span><br><span class="line">    &#125;</span><br><span class="line">    # id为用户名，secret为密码</span><br><span class="line">    eap-test &#123;</span><br><span class="line">        id = test</span><br><span class="line">        secret = &quot;123456&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>启动服务</p>
<p>注：直接启动strongswan时会有一个报错，提示没有这个service，直接把报错信息复制给GPT就行，我也忘记具体的指令了，就是创建一个文件使其能启动strongswan ipsec</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable strongswan</span><br><span class="line">sudo systemctl start strongswan</span><br><span class="line">sudo systemctl status strongswan</span><br></pre></td></tr></table></figure>

<!-- ![image-20240816083736097](E:\lab\IPsec.assets\image-20240816083736097.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image3.png" class="" title="image3"></li>
</ul>
</li>
</ul>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul>
<li>操作系统</li>
</ul>
<!-- ![image-20240816100339589](E:\lab\IPsec.assets\image-20240816100339589.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image4.png" class="" title="image4">

<ul>
<li><p>直接命令行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install strongswan</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 &#x2F;etc&#x2F;ipsec.conf</p>
<p>带文字注释的要修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config setup</span><br><span class="line">    charondebug=&quot;ike 2, knl 2, cfg 2&quot;</span><br><span class="line"></span><br><span class="line">conn %default</span><br><span class="line">    keyexchange=ikev2</span><br><span class="line">    ike=aes256-sha1-modp1024</span><br><span class="line">    esp=aes256-sha1</span><br><span class="line">    dpdaction=clear</span><br><span class="line">    dpddelay=300s</span><br><span class="line">    rekey=no</span><br><span class="line"></span><br><span class="line">conn ikev2-vpn</span><br><span class="line">    left=192.168.139.129 # 服务器ip</span><br><span class="line">    leftid=192.168.139.129 # 服务器ip</span><br><span class="line">    leftauth = pubkey</span><br><span class="line">    leftcert=server-cert.pem</span><br><span class="line">    leftsendcert=always</span><br><span class="line">    leftsubnet=192.168.139.0/24 # 两台机器所在的网段</span><br><span class="line">    right=192.168.139.130 # 本机ip</span><br><span class="line">    rightid=192.168.139.130 # 本机ip</span><br><span class="line">    rightsubnet=0.0.0.0/0</span><br><span class="line">    rightauth=eap-mschapv2</span><br><span class="line">    rightsendcert=never</span><br><span class="line">    eap_identity=test</span><br><span class="line">    auto=add</span><br></pre></td></tr></table></figure>
</li>
<li><p>证书和私钥</p>
<p>把在服务端生成的对应文件也放到客户端对应的目录下</p>
<!-- ![image-20240820171519672](E:\lab\strongswan\strongswan安装文档.assets\image-20240820171519672.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image5.png" class="" title="image5">
</li>
<li><p>配置<code>/etc/ipsec.secrets</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test : EAP &quot;test&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ipsec restart</span><br><span class="line">sudo ipsec up ikev2-vpn</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>客户端</p>
<!-- ![image-20240820165034674](E:\lab\IPsec.assets\image-20240820165034674.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image6.png" class="" title="image6">

<p>服务端</p>
<!-- ![image-20240820165401813](E:\lab\IPsec.assets\image-20240820165401813.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image7.png" class="" title="image7">]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>Strongswan</tag>
        <tag>IPsec</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/2024/05/23/Welcome/</url>
    <content><![CDATA[<p>Welcome to hourhl’s blog! </p>
]]></content>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》(一)</title>
    <url>/2024/05/24/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="客户端-服务器架构"><a href="#客户端-服务器架构" class="headerlink" title="客户端&#x2F;服务器架构"></a>客户端&#x2F;服务器架构</h2><ul>
<li>mysqld：MySQL服务器程序，运行该程序可以启动一个服务器进程</li>
<li>mysql：MySQL客户端程序，运行该程序可以发送请求并接收服务器的处理结果 </li>
<li>客户端与服务器的连接<span id="more"></span>
<ul>
<li>本质：进程间通信</li>
<li>网络通信协议：TCP&#x2F;IP</li>
<li>服务器默认端口：3306</li>
<li>服务器处理的流程：连接管理 -&gt; 解析与优化 -&gt; 存储引擎<ul>
<li><strong>连接管理</strong>：客户端可以携带主机信息、用户名与密码等信息，采用TCP&#x2F;TP、命名管道或者共享内存、UNIX套接字等方式连接服务端。每当有客户端信息验证通过，连接到服务器端进程时，服务器端就会创建一个线程进行交互；当通信结束后，并不会立即销毁该线程，而是缓存起来，当有新的客户端连接时，将这个线程分配给新的客户端</li>
<li><strong>解析与优化</strong>：查询缓存 -&gt; 语法解析 -&gt; 查询优化<ol>
<li>查询缓存 – 同样的请求会从缓存中查找结果，但是如果两个请求有任何字符上的不同，都会重新计算</li>
<li>查询优化 – 优化的结果是生成一个执行计划，可以通过<code>explain</code>来查看</li>
</ol>
</li>
<li><strong>存储引擎</strong>：默认引擎是InnoDB</li>
</ul>
</li>
<li>实现效果：客户端向服务器发送一段文本（SQL语句），服务器进程处理后再向客户端返回一段文本</li>
</ul>
</li>
</ul>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><ul>
<li>启动选项<ul>
<li>命令行修改<br><code>仅对当次启动生效</code> </li>
<li>配置文件修改<br><code>无论是Linux系统还是Windows系统，都有多个对应的配置文件查找路径，且路径之间有优先级</code></li>
</ul>
</li>
<li>系统变量<ul>
<li>系统变量有不同的作用范围，包括GLOBAL和SESSION</li>
<li>大部分的系统变量可以当作启动项来设置，但是有些系统变量是程序运行过程中自动生成，无法修改</li>
</ul>
</li>
</ul>
<h2 id="字符集和比较规则"><a href="#字符集和比较规则" class="headerlink" title="字符集和比较规则"></a>字符集和比较规则</h2><ul>
<li>将字符映射成二进制称为编码，反之为解码。人们抽象出一个字符集的概念来描述某个字符范围的编码规则<br><code>常见字符集：ASCII、ISO8859-1、GB2312等</code></li>
<li>每个字符集有多个比较规则，比如是否区分重音、是否区分大小写等</li>
</ul>
<h2 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h2><h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><ul>
<li>MySQL会将数据存放到数据目录下，可以在客户端<code>show variables like &#39;datadir&#39;</code>来查看数据目录</li>
<li>数据目录中存放着系统数据库、用户自定义的数据库以及一些系统相关文件<blockquote>
<ul>
<li><code>mysql</code> 系统数据库，在数据目录下有对应的子文件夹。该数据库存储MySQL的用户账户和权限信息、一些存储过程和事件的定义信息、一些运行过程中产生的日志信息、一些帮助信息以及时区信息等。</li>
<li><code>performance_schema</code> 系统数据库，在数据目录下有对应的子文件夹。该数据库主要保存MySQL服务器运行过程中的状态信息，包括统计最近执行了哪些语句、在执行过程的每个阶段花费了多长时间、内存的使用情况等。</li>
<li><code>information_schema</code> 系统数据库，在数据目录下<strong>没有</strong>对应的文件夹。该数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、视图、触发器、列、索引等。并不是真实的数据，而是以描述性信息的形式存在，也称之为元数据。</li>
<li><code>sys</code> 系统数据库，在数据目录下有对应的文件夹。主要通过视图的形式把information_schema和performance_schema结合起来，让开发人员更方便地了解MySQL服务器的性能。</li>
<li><code>用户数据库</code> 用户自定义的数据库，在数据目录下有对应的子文件夹。详细信息见下文。</li>
<li><code>服务器进程文件</code> 一个服务器程序对应着一个进程，该文件存储着相关的进程ID</li>
<li><code>服务器日志文件</code> 包括查询日志、错误日志、二进制日志、redo日志等</li>
<li><code>SSL和RSA证书与密钥文件</code></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="用户数据库"><a href="#用户数据库" class="headerlink" title="用户数据库"></a>用户数据库</h3><ul>
<li>当用户创建了一个数据库，系统就会在数据目录下创建一个同名的文件夹，并且在这个文件夹中生成一个名为dp.opt的文件，该文件存储了数据库的相关信息，包括字符集、比较规则等。<br><strong>在MySQL8.0中未见到</strong></li>
<li>每个数据库对应的子文件夹下有两类文件，一类是描述表结构的文件，一类是数据文件<ol>
<li><code>InnoDB</code> 在该引擎中，索引和用户记录都是当作数据来处理。数据存放在数据页中，采用表空间来管理数据页。表空间又包括多种类型，比如系统表空间和独立表空间<ol>
<li><code>系统表空间</code> InnoDB会在文件目录下创建一个名为<strong>ibdata1</strong>，大小为12MB的文件（当容量不够时会自扩展）<br><strong>MySQL8.0版本在数据目录根目录下存在一个ibdata1</strong></li>
<li><code>独立表空间</code> 在MySQL5.6.6及以后的版本中，默认把数据存放到独立表空间中。每当建立一个新的表，就会创建一个新的独立表空间，其文件名是<strong>表名.ibd</strong>，存放在该表所属的数据库的子文件夹下，同时还会创建一个<strong>表名.frm</strong>文件，来记录表格的相关信息。<br><strong>此处存疑：在MySQL8.0的数据库子目录下，我只看到了表名.idb,没有看到表名.frm</strong></li>
</ol>
</li>
<li><code>MyISAM</code> 在该引擎中，索引和用户记录是分开存放的。其对应的子文件夹下有三类文件，分别是记录表结构的<strong>表名.ibd</strong>、记录用户记录的<strong>表名.MYD</strong>以及记录索引的<strong>表名.MY1</strong>.</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》（三）</title>
    <url>/2024/08/14/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>常用的数据结构 - B+树</p>
<ol>
<li>高度平衡：所有叶子节点处于同一层</li>
<li>叶子节点存储索引列和主键值（或索引列和完整数据记录），由双向链表构成</li>
<li>除了叶子节点外，每个节点可以有多个子节点</li>
</ol>
</li>
<li><p>常见的索引类型</p>
<ul>
<li>按叶子节点存放的数据分类：聚簇索引（叶子节点存放完整的数据记录，通常主键作为排序条件）和二级索引（需要回表查询完整的数据记录，通常非主键列作为排序条件）</li>
<li>覆盖索引：需要查询的内容包含在索引列中</li>
<li>联合索引：也称复合索引、组合索引，该类型的索引包含了多个数据列，本质也是一个二级索引</li>
</ul>
</li>
<li><p>MyISAM引擎的细节和上述（InnoDB引擎）不完全一样。其将索引和数据分开存储。</p>
<blockquote>
<p>所有数据都存放在数据文件中，索引树存放对应的行号，根据行号查找对应的数据记录</p>
</blockquote>
</li>
</ul>
<h2 id="索引的构建及使用"><a href="#索引的构建及使用" class="headerlink" title="索引的构建及使用"></a>索引的构建及使用</h2><ul>
<li>InnoDB默认为主键构建一个聚簇索引，叶子节点包含完整的数据记录</li>
<li>用户可以为非主键构建二级索引，该B+树的非叶子节点存放索引列的值、主键值以及对应下一层索引页的页号，叶子节点存放索引列的值和主键值，需要根据主键值再去聚簇索引查找完整的数据记录，因此被称为二级索引</li>
<li>索引在逻辑层面上是B+树，在物理层面上是以页的形式存放，每一页都是同一层的节点，且页与页之间有双向指针相连。页内按照索引列的值大小排成单向链表。</li>
<li>索引页的布局与数据页类似，每一页都分成七个部分，其中数据部分分成若干组，每组中主键大的记录的偏移量会被存储在页目录中的槽中。</li>
<li>进行检索时，每条索引指向与其值相等的第一条记录所在的位置。</li>
</ul>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>提高查找效率</li>
<li>如果查找的结果需要按照索引条件分组或者排列，也能减少时间开支</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>维护索引需要额外的时间，比如插入数据导致的页面分裂，删除数据导致的索引重新排列等。</li>
<li>使用索引也需要时间。每次执行查询语句之前，都需要计算不同的索引所需的时间成本，生成一个执行计划。如果索引过多，就有可能导致这个生成执行计划的时间过长。</li>
<li>建立索引需要占用额外的空间。每创建一个索引就是构建一个新的二叉树，二叉树的节点需要占据空间。</li>
</ol>
<h2 id="如何创建合适的索引"><a href="#如何创建合适的索引" class="headerlink" title="如何创建合适的索引"></a>如何创建合适的索引</h2><ul>
<li><code>为常用作搜索条件的列创建索引</code>  为常出现在WHERE、ORDER BY、GROUP BY子句中的列创建索引，仅出现在查询列表中的列就不必要创建索引</li>
<li><code>不为含有太多重复值的列创建索引</code>  如果某列中重复的数值很多，该列就不适合作为快速搜索的条件，因此不必要创建索引</li>
<li><code>索引列的数据类型占用空间尽可能小</code>  为某列创建索引，索引树的节点中就都存放有该列的值，如果值的类型占用的存储空间太大，就会产生不必要的空间消耗。例如使用INT类型就足够表示，就不必要使用BIGINT类型。</li>
<li><code>为列前缀创建索引</code>  可以将字符串中的前几个字符存放到索引中。</li>
<li><code>创建覆盖索引</code>  常出现在查询列表中的列可以创建覆盖索引，这样B+树中的叶子节点就有需要的结果，不需要回表查询，减少时间开销。</li>
<li><code>不要在搜索条件中进行索引列的运算</code>  例如以key列创建了索引，如果WHERE子句中的搜索条件是WHERE key * 2 &lt; 4，那么MySQL将使用全表扫描而不使用索引。</li>
<li><code>表的主键设置为自动递增</code>  MySQL默认为表格的主键列创建聚簇索引，如果主键不是递增的，那么插入新记录时就有可能导致正好插入到已满的数据页的中间，此时MySQL需要进行页面分裂，并把一些数据移动到新的页面中，造成无谓的性能损耗。</li>
<li><code>不要创建冗余和重复索引</code>  例如本身已经创建了一个针对key1\key2的联合索引，就不需要单独再为key1创建索引了</li>
</ul>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》（二）</title>
    <url>/2024/08/03/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><code>MySQL中有不同的存储引擎，其存储方式均有所不同，以下仅以InnoDB引擎为例</code></p>
<ul>
<li><strong>读取方式：页</strong> InnoDB将数据库中的数据划分为若干页，每次进行数据存取是都以页为单位，页的大小是16KB.每一个页面上以记录的形式存放着相关数据，每条记录又可分为真实数据、额外数据和隐藏列（以COMPACT行格式为例），额外数据是用来辅助存储和读取信息的，包括变长字段长度列表、NULL值列表和记录头信息。<span id="more"></span>
<ol>
<li><p><strong>变长字段长度列表</strong> 常见的变长字段类型包括VARCHAR、TEXT类型等，这些数据类型的长度是不固定的，为了从记录中准确读取它的内容，就需要记录它所占据的字节数。</p>
<ul>
<li>变长字段的长度是按逆序存放的。例如变长字段1占据3字节，字段2占据8字节，则变长字段长度列表的存放就是0x080x03。</li>
<li>假设某个字段L是VARCHAR(m)类型，采用的字符集最多需要使用w字节来表示一个字符，且其真实占用的字节数是L。当m×w的乘积结果小于等于255，则其只需要用1个字节来存放它的长度；当乘积结果大于255且L也大于127，则需要用2两个字节来存放它的长度，否则用1个字节即可。</li>
<li>变长字段长度列表只存储值为非NULL的变长字段列。</li>
</ul>
</li>
<li><p><strong>NULL值列表</strong> 该列表仅在表中允许存储NULL值的列存在的时候存在。其值等同于对应列按整数个字节逆序存放，并且用二进制表示。例如有三个列允许NULL值存在，且仅有第二和第三列为NULL，则其对应的NULL值列表的二进制表示为00000110。由于仅有三个列，需要1个字节来存放即可，高位用0补全，同时考虑到第二和第三列为NULL，正常情况为<code>0</code> <code>1</code> <code>1</code>，根据COMPACT行格式的存放规则，需要逆序存放，故得到的结果为00000110，即0x06。</p>
</li>
<li><p><strong>记录头信息</strong> 该部分固定由5字节组成，用于描述记录的一些属性。此处仅列出比较重要的字段，不再多做赘述，可以查找资料了解即可。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">大小（bit）</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n_owned</td>
<td align="center">4</td>
<td align="center">组中的领头节点记录该组中的记录条数</td>
</tr>
<tr>
<td align="center">deleted_flag</td>
<td align="center">1</td>
<td align="center">标记该记录是否被删除</td>
</tr>
<tr>
<td align="center">min_rec_flag</td>
<td align="center">1</td>
<td align="center">B+树中每层非叶子节点的最小的目录项</td>
</tr>
<tr>
<td align="center">heap_no</td>
<td align="center">13</td>
<td align="center">当前记录在堆中的相对位置</td>
</tr>
<tr>
<td align="center">record_type</td>
<td align="center">3</td>
<td align="center">当前记录的类型</td>
</tr>
<tr>
<td align="center">next_record</td>
<td align="center">16</td>
<td align="center">下一条记录的位置</td>
</tr>
</tbody></table>
</li>
<li><p><strong>隐藏列</strong> 包括row_id、trx_id和roll_pointer。row_id非必须，只有表中没有定义主键，也没有不允许存储NULL值的UNIQUE键时，才会添加该字段,占用6字节。trx_id时必须的，占用6字节，属于事务id。roll_pointer也是必须的，占用7字节，用于进行事务回滚。</p>
</li>
</ol>
</li>
<li><strong>溢出列</strong> 当某条记录所占空间过大时，在记录的真实数据处只会存放该字段的部分数据，然后用20字节指向剩余数据存放页的位置。</li>
</ul>
<h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><ul>
<li><p>数据页大小为16KB，主要可以分为七大部分，分别是<code>File Header</code> \ <code>Page Header</code> \ <code>Infimum + Supremum</code> \ <code>User Records</code> \ <code>Fres Space</code> \ <code>Page Directory</code> \ <code>File Trailer</code>.</p>
<table>
<thead>
<tr>
<th align="center">模块</th>
<th align="center">占用空间（字节）</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">文件头</td>
<td align="center">38</td>
<td align="center">页的通用信息</td>
</tr>
<tr>
<td align="center">页面头</td>
<td align="center">56</td>
<td align="center">数据页的专有信息</td>
</tr>
<tr>
<td align="center">页面的最大记录和最小记录</td>
<td align="center">26</td>
<td align="center">两个虚拟记录</td>
</tr>
<tr>
<td align="center">数据（用户记录）</td>
<td align="center">不定</td>
<td align="center">用户存储的数据</td>
</tr>
<tr>
<td align="center">空白区域</td>
<td align="center">不确定</td>
<td align="center">页面中尚未使用的空间</td>
</tr>
<tr>
<td align="center">页目录</td>
<td align="center">不确定</td>
<td align="center">页面中某些记录的相对位置</td>
</tr>
<tr>
<td align="center">文件尾</td>
<td align="center">8</td>
<td align="center">校验页的完整性</td>
</tr>
</tbody></table>
</li>
<li><p>数据相关操作</p>
<ul>
<li><strong>增</strong> - 往用户记录空间插入一条记录<ol>
<li>每个页中都有两条默认插入的记录，分别是最小记录Infimum和最大记录Supremum，记录的大小通过主键的大小来确定，这两条是默认最大和最小的，但这两条记录存放在用户记录区域的靠前部分。</li>
<li>页面中所有记录都会分组，Infimum所在的组只能有1条记录，即它自己，Supremum所在的记录数量限制在1-8条，其余组的记录数量限制在4-8条。新增的记录从最近的比它大的记录所在的组开始插入。当组中记录的数量达到9条，从中间划分，生成一个新的组，前一个组的大小为4，后一个组的大小为5。</li>
</ol>
</li>
<li><strong>删</strong> - 从用户记录空间删除一条记录<ol>
<li>被删除的记录并不会直接从磁盘中删除，而是修改deleted_flag，其值为1时表示被删除，同时修改其next_record值为1，表示没有下一条记录。</li>
<li>所有被删除的记录会组成一个垃圾链表，按照主键由小到大的顺序链接，这些链表占用的空间被称为可重用空间。</li>
</ol>
</li>
<li><strong>查</strong> - 从用户记录空间查询一条记录<ol>
<li>每一组中最后一条记录的真实数据与该页开头的偏移量称为槽，按照组的逆序排列在页目录中，且从靠近文件尾的部分开始存储，每个槽占用2个字节。<img src="/2024/08/03/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/datatype-structure.png" class="" width="200" title="datatype-structure"></li>
<li>按照二分法，low &#x3D; 槽0， high &#x3D; 槽n,先计算中间的槽的主键值（对应该组中最大的记录的主键值），然后修改low或者high。直到确认目标主键在哪一组中，遍历该组即可。（每一组最多只有8条记录，遍历速度很快）</li>
</ol>
</li>
</ul>
</li>
<li><p>记录头信息</p>
<ol>
<li>n_owned : 每个页面中的记录会分为若干个组，组内最大的记录会记录该组内有多少条记录</li>
<li>heap_no : 存放在页面前面的记录heap_no值偏小，每新生成一条记录的存储空间，其值都比物理位置在它前面的那条记录的heap_no值大1。heap_no从2开始，因为0和1分别指代了Infimum和Supremum。</li>
<li>record_type : 0表示普通记录，1表示B+树非叶子节点的目录项记录，2表示Infimum，3表示Supremum。</li>
<li>next_record ： 当前记录的数据部分到下一条记录的数据部分。注意每条记录由记录头部分和数据部分组成，这个指向的是数据部分的开头，这样的好处是向后可以遍历数据，向前可以遍历该记录的记录头。当这个值为正数，说明下一条记录（指按主键排列的下一条记录，不是插入顺序的下一条记录）在当前记录的后面，反之在前面。规定Infimum记录的下一条记录就是当前页面主键值最小的记录，Supremum记录的next_record值为0，表示没有下一条记录。</li>
</ol>
</li>
<li><p>页面头<br>页面头是页结构的第二部分，占用56字节，其各个部分的作用如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">占用空间（字节）</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td align="center">页目录中的槽数量</td>
</tr>
<tr>
<td align="center">PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td align="center">空闲空间起始地址</td>
</tr>
<tr>
<td align="center">PAGE_N_HEAP</td>
<td align="center">2</td>
<td align="center">前1比特表示本记录是否为紧凑型的记录，后15bit表示本页中记录的数量，包括Infimum和Supremum，以及删除的记录）</td>
</tr>
<tr>
<td align="center">PAGE_FREE</td>
<td align="center">2</td>
<td align="center">已删除的记录链表中起始记录所在的偏移地址</td>
</tr>
<tr>
<td align="center">PAGE_GARBAGE</td>
<td align="center">2</td>
<td align="center">已删除的记录占用的字节数</td>
</tr>
<tr>
<td align="center">PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td align="center">最后插入的记录的位置</td>
</tr>
<tr>
<td align="center">PAGE_DIRECTION</td>
<td align="center">2</td>
<td align="center">记录插入的方向（新插入的记录的主键比上一条大或者小，前者认为是向右，否则向左）</td>
</tr>
<tr>
<td align="center">PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td align="center">一个方向连续插入的记录数量（仅记录最新值）</td>
</tr>
<tr>
<td align="center">PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td align="center">修改当前页的最大事务id，该值仅在二级索引页面中定义</td>
</tr>
<tr>
<td align="center">PAGE_LEVEL</td>
<td align="center">2</td>
<td align="center">当前页在B+树中所处的层级</td>
</tr>
<tr>
<td align="center">PAGE_INDEX_ID</td>
<td align="center">8</td>
<td align="center">当前页属于的索引id</td>
</tr>
<tr>
<td align="center">PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td align="center">B+树叶子节点段的头部信息，仅在B+树的根页面中定义</td>
</tr>
<tr>
<td align="center">PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td align="center">B+树非叶子节点段的头部信息，仅在B+树的根页面中定义</td>
</tr>
</tbody></table>
</li>
<li><p>文件头<br>文件头是页结构的第一部分，占用38字节，其各个部分的作用如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">占用空间（字节）</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FIL_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td align="center">在MySQL4.0.14之后的版本中，该属性表示页的校验和</td>
</tr>
<tr>
<td align="center">FIL_PAGE_OFFSET</td>
<td align="center">4</td>
<td align="center">页号</td>
</tr>
<tr>
<td align="center">FIL_PAGE_PREV</td>
<td align="center">4</td>
<td align="center">上一页的页号</td>
</tr>
<tr>
<td align="center">FIL_PAGE_NEXT</td>
<td align="center">4</td>
<td align="center">下一页的页号</td>
</tr>
<tr>
<td align="center">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td align="center">页面被最后修改时对应的LSN值（Log Sequence Number,日志序列号）</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE</td>
<td align="center">2</td>
<td align="center">该页的类型</td>
</tr>
<tr>
<td align="center">FIL_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td align="center">仅在系统表空间的第一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td align="center">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td align="center">页属于哪个表空间</td>
</tr>
</tbody></table>
<p>其中FIL_PAGE_TYPE表示某个页面的类型，包括日志页、溢出页等，其可能的值见下表。</p>
<table>
<thead>
<tr>
<th align="center">类型名称</th>
<th align="center">值</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FIL_PAGE_TYPE_ALLOCATED</td>
<td align="center">0x0000</td>
<td align="center">新分配未使用</td>
</tr>
<tr>
<td align="center">FIL_PAGE_UNDO_LOG</td>
<td align="center">0x002</td>
<td align="center">undo日志页</td>
</tr>
<tr>
<td align="center">FIL_PAGE_INODE</td>
<td align="center">0x003</td>
<td align="center">存储段信息</td>
</tr>
<tr>
<td align="center">FIL_PAGE_IBUF_FREE_LIST</td>
<td align="center">0x004</td>
<td align="center">Change Buffer空闲列表</td>
</tr>
<tr>
<td align="center">FIL_PAGE_IBUF_BITMAP</td>
<td align="center">0x005</td>
<td align="center">Change Buffer的属性</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_SYS</td>
<td align="center">0x006</td>
<td align="center">系统数据</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_TRX_SYS</td>
<td align="center">0x007</td>
<td align="center">事务系统数据</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_FSP_HDR</td>
<td align="center">0x008</td>
<td align="center">表空间头部信息</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_XDES</td>
<td align="center">0x009</td>
<td align="center">存储区的属性</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_BLOB</td>
<td align="center">0x00A</td>
<td align="center">溢出页</td>
</tr>
<tr>
<td align="center">FIL_PAGE_INDEX</td>
<td align="center">0x45BF</td>
<td align="center">索引页，也就是我们说的数据页</td>
</tr>
</tbody></table>
</li>
<li><p>文件尾</p>
<ol>
<li>文件尾是页的最后一部分，占用8个字节。主要用于进行页面的校验。</li>
<li>文件尾的前4个字节是该页面的校验和，正常情况下其值等于文件头中的校验和。如果该页面被修改，会重新计算这两个部分的校验和。当该页面被刷新到磁盘中时，由于文件头在前，其值会被先写入磁盘。如果刷新页面的过程中发生了断电，重启服务后只需比较页面中的两个校验和即可，如果两个校验和相等，说明该页刷新成功，否则说明该页在刷新过程中发生了错误。</li>
<li>文件尾的后四个字节表示最后修改时对应的LSN的值，正常情况下与文件头中的FILE_PAGE_LSN相等。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》（五）</title>
    <url>/2024/09/15/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h1 id="InnoDB的表空间"><a href="#InnoDB的表空间" class="headerlink" title="InnoDB的表空间"></a>InnoDB的表空间</h1><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><ul>
<li>《MySQL是怎样运行的（一）》中提到，每创建一个数据库schema，就会在MySQL数据目录下创建一个同名的文件夹schema，当在数据库（指MySQL5.6.6及以后的版本）中创建一个表格table时，默认采用独立表空间，即会在schema文件夹中创建一个同名的frm文件（table.frm）和ibd文件（table.ibd）。其中frm文件记录表格的基本信息，包括表名、列名、列长度、主键以及索引等，ibd文件则存储记录、索引、MVCC等相关信息。</li>
<li>独立表空间和系统表空间是InnoDB引擎独有的物理文件存储结构，其他引擎比如MyISAM不支持这个概念。</li>
</ul>
<h2 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><ul>
<li>InnoDB是以页的形式存储数据，完整的数据记录是以聚簇索引的形式存放，也就是说，完整的数据记录的存储逻辑也是B+树，不是我们主观上认为的二维表格，即聚簇索引和完整的数据记录不是分开存储的，实际上二者是一体的，聚簇索引就是完整的表格数据。</li>
<li>每张表格对应的索引数目就是用户设置的索引数加1（聚簇索引）。</li>
<li>每次往表格中添加记录时，会先更新聚簇索引，再更新相关的二级索引</li>
<li>B+树的节点就是数据页，数据页之间用指针相连。数据页（也就是INDEX类型的页，详情见《MySQL是怎样运行的（二）》）由七个部分组成，其中首尾部分分别是File Header和File Trailer，这两个部分是所有类型的页面通用的。</li>
</ul>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><ul>
<li>一个idb文件对应一个表格，实际上就是一个独立表空间。每个独立表空间可以划分为多个组，每个组由256个区（extend）组成，每个区默认大小为1MB，即连续的64个页(每个页默认16KB)。<img src="./image1.png" width="60%" height="60%" /></li>
<li>每个独立表空间中，第一个组最开始的三个页面类型是FSP_HDR\IBUF_BITMAP\INODE，其余组的最开始两个页面类型是XDES\IBUF_BITMAP。（注：每个独立表空间只有一个FSP_HDR类型的页面）</li>
</ul>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul>
<li>为了减少随机IO，开发者将同一个索引B+树的页面尽可能在物理存储上也放在一起，因此同一个B+树的页面尽可能分配在同一个组，同时将叶子节点和非叶子节点分开存放。</li>
<li>开发者将每个索引在逻辑上分为两个段，分别是叶子节点段和非叶子节点段。</li>
<li>段和区的关系<ul>
<li>段是逻辑上的概念，区是表空间中连续的64个页面</li>
<li>区有4种分类，分别是空闲区，有剩余页面的碎片区，没有剩余页面的碎片区、属于某个段的区</li>
<li>碎片区的页面可以分给不同的段</li>
</ul>
</li>
<li>为某个段分配存储空间的策略如下<ol>
<li>当表格数据不多时，从碎片区选择单个空页面来分配存储空间</li>
<li>当某个段已经占用了32个碎片区页面后，就会以完整的区来分配存储空间（原先占用的碎片区页面并不会被复制到新申请的完整区之中）</li>
</ol>
</li>
</ul>
<h3 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h3><h4 id="区"><a href="#区" class="headerlink" title="区"></a>区</h4><ul>
<li>空闲区<ul>
<li>属于整个独立表空间</li>
<li>通过链表的形式连接起来，链表头存放在第一个区中的第1个页面中（即FSP_HDR）</li>
<li>链表的节点类型是XDES Entry，状态为FREE，Segment ID无效<img src="./image2.png" width="50%" height="50%" />
其中的State就是前面提到的区的分类，可选的值分别是FREE(空闲区)、FREE_FRAG(有空闲页面的碎片区)、FULL_FRAG（没有空闲页面的碎片区）、FSEG（属于某个段的区）</li>
<li>链表头节点的类型是List Base Node<img src="./image3.png" width="60%" height="60%" /></li>
</ul>
</li>
<li>碎片区<ul>
<li>属于整个独立表空间</li>
<li>通过链表的形式连接起来，链表头存放在第一个区中的第1个页面中（即FSP_HDR）</li>
<li>链表的节点类型是XDES Entry，状态为FREE_FRAG（有空闲页面的碎片区）或者FULL_FRAG（没有空闲页面的碎片区），Segment ID无效</li>
<li>链表头节点的类型是List Base Node</li>
</ul>
</li>
<li>属于段的区<ul>
<li>属于某个段</li>
<li>通过链表的形式连接起来，链表头存放在第一个区中的第1个页面中（即FSP_HDR）</li>
<li>链表的节点类型是XDES Entry，Segment ID为对应段的ID</li>
<li>链表头节点的类型是List Base Node</li>
</ul>
</li>
</ul>
<h4 id="段"><a href="#段" class="headerlink" title="段"></a>段</h4><ul>
<li>段是一个逻辑上的概念，其物理上包括多个零散的页面和多个区，其中零散的页面属于碎片区。</li>
<li>由于每个索引都有两个段，因此也需要设计相关的结构来存储相关信息。</li>
<li>段的属性存储在INODE Entry中，INODE Entry也由链表连接起来，属于链表的节点<img src="./image4.png" width="60%" height="60%" />

<blockquote>
<p><strong>Segment ID</strong> - 每个段独有的编号<br><strong>NOT_FULL_N_USED</strong> - 在NOT_FULL链表中已经用了多少个页面<br><strong>List Node Base</strong> - 分别记录空链表、未满链表和满链表的头结点<br><strong>Magic Number</strong> - 标记该INODE Entry是否已经完整填入相关信息，是则初始化该字段为97937874<br><strong>Fragment Array Entry</strong> - 该段对应的零散页面的页号</p>
</blockquote>
</li>
</ul>
<h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><ul>
<li>前面提到，独立表空间分为多个组，每个组由256个区组成，每个区又由64个页面组成，即独立表空间可以分成多个组，每个组有256 × 64 &#x3D; 16384个页面。</li>
<li>每个组的前几个页面是固定的。第一个组的前三个页面的页面类型分别是FSP_HDR、IBUF_BITMAP、INODE，其余组的前两个页面的页面类型分别是XDES、IBUF_BITMAP。</li>
<li>FSP_HDR<img src="./image5.png" width="60%" height="60%" />
* File Space Header存储整个独立表空间的属性

<table>
<thead>
<tr>
<th align="center">字段名称</th>
<th align="center">占用空间(&#x2F;字节)</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Space ID</td>
<td align="center">4</td>
<td align="center">表空间的ID</td>
</tr>
<tr>
<td align="center">Not Used</td>
<td align="center">4</td>
<td align="center">未使用，可忽略</td>
</tr>
<tr>
<td align="center">Size</td>
<td align="center">4</td>
<td align="center">当前表空间拥有的页面数</td>
</tr>
<tr>
<td align="center">Free Limit</td>
<td align="center">4</td>
<td align="center">未被初始化的最小页号，即大于或等于这个页号的页面的区对应的XDES Entry 结构没有被加入Free链表</td>
</tr>
<tr>
<td align="center">Space Flags</td>
<td align="center">4</td>
<td align="center">表空间的一些占用存储空间比较小的属性</td>
</tr>
<tr>
<td align="center">FRAG_N_USED</td>
<td align="center">4</td>
<td align="center">FREE_FRAG链表中已使用的页面数量</td>
</tr>
<tr>
<td align="center">List Base Node for FREE list</td>
<td align="center">16</td>
<td align="center">FREE链表的头结点</td>
</tr>
<tr>
<td align="center">List Base Node for FREE_FRAG list</td>
<td align="center">16</td>
<td align="center">FREE_FRAG链表的头结点</td>
</tr>
<tr>
<td align="center">List Base Node for FULL_FRAG list</td>
<td align="center">16</td>
<td align="center">FULL_FRAG链表的头结点</td>
</tr>
<tr>
<td align="center">Next Unused Segment ID</td>
<td align="center">8</td>
<td align="center">当前表空间中下一个未使用的Segment ID</td>
</tr>
<tr>
<td align="center">List Base Node for SEG_INODES_FULL list</td>
<td align="center">16</td>
<td align="center">SEG_INODES_FULL链表的头结点</td>
</tr>
<tr>
<td align="center">List Base Node for SEG_INODES_FREE list</td>
<td align="center">16</td>
<td align="center">SEG_INODES_FREE链表的头结点</td>
</tr>
</tbody></table>
每个段对应的INODE Entry结构会集中存放到INODE页面中（即整个表空间的第三个页面），但如果索引很多，就会导致段很多，一个INODE页面无法完整存放所有数据，此时就会有多个INODE类型的页面来组成链表。SEG_INODES_FREE链表中的页面还有空间，SEG_INODES_FULL中的页面没有多余空间</li>
<li>IBUF_BITMAP<ul>
<li>记录了有关Change Buffer的相关信息</li>
</ul>
</li>
<li>INODE<ul>
<li>该类型的页面主要用于存储段的相关信息<img src="./image6.png" width="60%" height="60%" /></li>
<li>当索引足够多时，就会导致段的数目过多，因此一个INODE页面无法存下所有的INODE Entry，需要多个INODE类型的页面来存储。此时就0号页面FSP_HDR中的SEG_INODES_FULL list和SEG_INODES_Free list相呼应</li>
<li>存储INODE Entry的过程大致如下:每当新创建一个段<ol>
<li>先从SEG_INODES_Free中查看是否为空，如果不空，则从中获取一个节点，相当于获取一个未写满的INODE页面，填充入新的段对应的INODE Entry。当这个页面填满后，就将其放入SEG_INODES_Full链表中</li>
<li>如果SEG_INODES_Free链表为空，就需要从表空间的FREE_FRAG链表中申请一个新的页面，并将该页面类型修改为INODE，填入新的段对应的INODE Entry后，如果没有满，则将其放入SEG_INODES_Free中，否则放入SEG_INODES_Full中。</li>
</ol>
</li>
</ul>
</li>
<li>XDES<ul>
<li>与<strong>FSP_HDR</strong>页面几乎一样，只是FSP_HDR的File Space Header部分变为不进行使用</li>
</ul>
</li>
</ul>
<h2 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h2><ul>
<li>整个MySQL进程只有一个系统表空间，需要记录整个系统的相关信息。</li>
<li>系统表空间也分为若干个qu，每个区的前几个页面也是有固定的格式。</li>
<li>关于系统表空间的内容本文不再详细描述。</li>
</ul>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据页</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客(Hexo + Github)</title>
    <url>/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>参考<br><a href="https://cloud.tencent.com/developer/article/2337246">使用Hexo从0到1搭建个人博客详细教程（超详细，超简单）</a><br><a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细）</a><br><a href="https://goldstine.github.io/create_blog_with_github_pages/">可能是最全面的github pages搭建个人博客教程</a></p>
<span id="more"></span>

<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><ul>
<li>安装node.js</li>
<li>配置npm安装的默认目录，并安装webpack<!-- ![](/_posts/搭建个人博客/image1.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image1.png" class="" title="image1"></li>
<li>安装博客网站的框架Hexo<ul>
<li>在Github新建一个仓库</li>
<li>本地新建一个Blog文件夹，在该目录下打开Git Bash，输入npm命令安装Hexo<!-- ![](/source/_posts/搭建个人博客/image2.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image2.png" class="" title="image2"></li>
<li>初始化博客<!-- ![](/source/_posts/搭建个人博客/image3.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image3.png" class="" title="image3"></li>
<li>静态部署<!-- ![](/source/_posts/搭建个人博客/image4.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image4.png" class="" title="image4"></li>
<li>启动服务器<!-- ![](/source/_posts/搭建个人博客/image5.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image5.png" class="" title="image5"></li>
<li>浏览器访问<!-- ![](/source/_posts/搭建个人博客/image6.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image6.png" class="" title="image6">
本地部署完成</li>
</ul>
</li>
<li>将Hexo部署到Github<ul>
<li>在Blog文件夹下找到_config.yml并打开，在文件末尾追加<!-- ![](/source/_posts/搭建个人博客/image7.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image7.png" class="" title="image7"></li>
<li>还是在Blog文件夹下打开Git Bash，安装git部署插件<!-- ![](/source/_posts/搭建个人博客/image8.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image8.png" class="" title="image8"></li>
<li>清理缓存并重新部署<!-- ![](/source/_posts/搭建个人博客/image9.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image9.png" class="" title="image9"></li>
<li>浏览器访问<!-- ![](/source/_posts/搭建个人博客/image11.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image11.png" class="" title="image11">
部署成功</li>
</ul>
</li>
<li>绑定域名<ul>
<li>从阿里云购买一个域名，在域名控制台点击“解析”<!-- ![](/source/_posts/搭建个人博客/image12.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image12.png" class="" title="image12"></li>
<li>添加两条记录，其中第一条记录值可以ping 仓库名得到<!-- ![](/source/_posts/搭建个人博客/image18.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image18.png" class="" title="image18">
<!-- ![](/source/_posts/搭建个人博客/image19.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image19.png" class="" title="image19"></li>
<li>在Blog\source下新建一个CNAME文件，写入购买的域名<!-- ![](/source/_posts/搭建个人博客/image14.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image14.png" class="" title="image14"></li>
<li>还是在Blog文件夹下，打开Git Bash，依次执行以下代码<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
<li>查看repo的setting-&gt;Pages,Custom domain已经配置好了<!-- ![](/source/_posts/搭建个人博客/image15.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image15.png" class="" title="image15">
<!-- ![](/source/_posts/搭建个人博客/image16.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image16.png" class="" title="image16"></li>
<li>直接访问该域名<!-- ![](/source/_posts/搭建个人博客/image17.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image17.png" class="" title="image17"></li>
</ul>
</li>
</ul>
<h1 id="部署到云服务器"><a href="#部署到云服务器" class="headerlink" title="部署到云服务器"></a>部署到云服务器</h1><p>可参考 <a href="https://cloud.tencent.com/developer/article/1662792">Hexo进阶教程（四）| 部署Hexo到自己的服务器</a></p>
<h1 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h1><ul>
<li>以Cactus主题为例<ul>
<li><a href="https://github.com/probberechts/hexo-theme-cactus?tab=readme-ov-file#install">Cactus官方使用文档</a></li>
<li>在Blog目录下打开Git Bash，执行git clone<!-- ![](/source/_posts/搭建个人博客/image22.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image22.png" class="" title="image22"></li>
<li>修改_config.yml<!-- ![](/source/_posts/搭建个人博客/image23.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image23.png" class="" title="image23"></li>
<li>进入&#x2F;theme&#x2F;cactus文件夹下，修改_config.yml,选择自己喜欢的scheme<!-- ![](/source/_posts/搭建个人博客/image25.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image25.png" class="" title="image25"></li>
<li>重新启动hexo<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
<li>博客页面的主题已经被成功切换<!-- ![](/source/_posts/搭建个人博客/image26.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image26.png" class="" title="image26"></li>
<li>优化主题可参考<a href="https://zhuanlan.zhihu.com/p/106060640">个人博客第8篇——优化主题（持续更新）</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》（四）</title>
    <url>/2024/09/06/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><ol>
<li>MySQL执行查询语句的方式称为访问方法或者访问类型。同一个查询语句可以有多个访问方法来执行，不同访问方法进行查询的结果保持一致，但是所需的成本不同。</li>
<li><strong>const</strong> 通过主键或者唯一二级索引列与常数的等值比较的访问方法。如果主键或者二级索引是由多个列来组成，则必须每一列都进行等值比较。<blockquote>
<ul>
<li>该访问方法被认为是常数级别的</li>
<li>利用二级索引进行查询，并且查询条件为NULL时，不采用const访问方法。</li>
</ul>
</blockquote>
</li>
<li><strong>ref</strong> 通过二级索引列与常数进行等值比较，并且形成的扫描区间为单点扫描区间的访问方法。<blockquote>
<ul>
<li>采用二级索引来进行查询时，每找到一条符合条件的二级索引，都会立即回表查询，而不是得到所有的主键id再统一进行回表。</li>
<li>当查询的值为NULL时，最多只能使用ref查询方法。</li>
<li>对于索引列中包含多个列的索引来说，只要左边的列与常数进行等值比较，都可以用ref，如果是范围比较，就不能用ref。</li>
</ul>
</blockquote>
</li>
<li><strong>ref_or_null</strong> 比ref方法多了搜索条件为NULL。<blockquote>
<ul>
<li>值为NULL的记录会被放在索引树的最左边</li>
</ul>
</blockquote>
</li>
<li><strong>range</strong> 使用索引查询时，对应的扫描区间为若干个单点扫描区间或者范围扫描区间的单表访问方法。</li>
<li><strong>index</strong> 扫描全部二级索引记录的访问方法。<blockquote>
<ul>
<li>index访问方法的应用场景可以如下：查询结果是覆盖索引中对应的列，但是搜索条件不是按索引列的从左到右来的，可能是中间某个列或者某几个列。但是由于所要的结果在索引中已经存在，不需要再次回表查询了，仅需要扫描该索引即可。</li>
</ul>
</blockquote>
</li>
<li><strong>all</strong> 执行全表扫描的访问方法。</li>
</ol>
<h3 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h3><ol>
<li><strong>索引合并</strong> 使用多个索引来完成一次查询的方法</li>
<li><strong>Intersection索引合并</strong> 利用不同的索引分别进行扫描，得到的结果取交集，再利用得到的结果来进行回表。<blockquote>
<p>要求使用二级索引的必须是等值查询，并且如果是联合索引，要求每一个索引列都要覆盖。原因：当二级索引的值相同时，叶子节点是根据主键排列的，便于取交集，并且在后续回表的过程中更有利于读取信息，而不是随机I&#x2F;O。<br>select * from table where key1 &#x3D; 10 and key2 &#x3D; 20;</p>
</blockquote>
</li>
<li><strong>Union索引合并</strong> 利用不同的索引分别进行扫描，得到的结果取并集，再利用得到的结果来进行回表。<blockquote>
<p>同样要求用二级索引的必须是等值查询，并且如果是联合索引，要求每一个索引列都要覆盖。原因：便于取并集，回表时的效率也高。<br>select * from table where key1 &#x3D; 10 or key2 &#x3D; 20;</p>
</blockquote>
</li>
<li><strong>sort-union索引合并</strong> 利用不同索引分别进行扫描，得到结果先排序再取并集。<blockquote>
<p>不要求二级索引必须等值查询，也不要求联合索引的每一个列都得是等值查询<br>select * from table where key1 &gt; 10 and index_part1 &#x3D; 1;</p>
</blockquote>
</li>
</ol>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><ul>
<li>连接的本质就是把各个表中的记录都取出来进行一次匹配，并把匹配后的组合发送给客户端</li>
<li><strong>驱动表</strong>即第一个需要查询的表，再根据驱动表到被<strong>驱动表</strong>中找匹配的记录。也就是说，驱动表只需要访问一次，被驱动表可能需要访问多次。每获得一条驱动表记录，都需要到被驱动表中寻找匹配的记录。</li>
</ul>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><ul>
<li>对于进行内连接查询的表，如果驱动表中的记录在被驱动表中没找到对应的，那就不会加入结果集中。</li>
<li>内连接的查询基本步骤如下<ol>
<li>选取驱动表，适用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询</li>
<li>对步骤1中查询驱动表中得到的结果集中的每一条记录，都分别到被驱动表中查找匹配的记录。</li>
</ol>
</li>
</ul>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><ul>
<li>对于进行外连接查询的表(包括左外连接和右外连接)，即使驱动表中的记录在被驱动表中没找到对应的，还是会加入到结果集。</li>
<li>左外连接 - 选择左侧的表为驱动表</li>
<li>右外连接 - 选择右侧的表为驱动表<blockquote>
<p>where子句中不符合条件的记录，不管是外连接还是内连接，都不会加入结果集。<br>on子句的处理方式就很符合内外连接的区别。如果不符合条件，在内连接中就不会加入结果集，但是在外连接中会加入结果集。</p>
</blockquote>
</li>
</ul>
<h2 id="计算成本"><a href="#计算成本" class="headerlink" title="计算成本"></a>计算成本</h2><ul>
<li>一条查询语句的执行成本包括I&#x2F;O成本和CPU成本。前者指把记录从磁盘加载到内存中的时间，后者指读取记录、判断记录是否满足搜索条件、对结果进行排序等操作所损耗的时间。</li>
<li>成本常数<ul>
<li>读取一个页面的成本默认为1.0</li>
<li>检测一个记录是否符合搜索条件的成本默认是0.2</li>
</ul>
</li>
</ul>
<h3 id="单表查询成本"><a href="#单表查询成本" class="headerlink" title="单表查询成本"></a>单表查询成本</h3><ul>
<li>执行一条查询语句的基本步骤<ol>
<li>根据搜索条件，查找所有能用的索引</li>
<li>计算全表扫描的成本</li>
<li>计算使用各种索引的成本</li>
<li>对比各种执行方案的代价，选择成本最低的方案</li>
</ol>
</li>
</ul>
<h3 id="连接查询成本"><a href="#连接查询成本" class="headerlink" title="连接查询成本"></a>连接查询成本</h3><ul>
<li>当多张表连接查询时，驱动表访问一次，被驱动表访问多次，因此连接查询的成本是由单次查询驱动表的成本和多次查询被驱动表的成本组成。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>查询</tag>
      </tags>
  </entry>
  <entry>
    <title>撰写博客(Hexo + Github)</title>
    <url>/2024/05/27/%E6%92%B0%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="新建md文件"><a href="#新建md文件" class="headerlink" title="新建md文件"></a>新建md文件</h1><ul>
<li><code>hexo n filename</code> – 在&#x2F;source&#x2F;_posts文件夹下生成一个filename.md<img src="/2024/05/27/%E6%92%B0%E5%86%99%E5%8D%9A%E5%AE%A2/image1.png" class="" title="image1"></li>
<li>参照<a href="https://markdown.com.cn/basic-syntax/">Markdown 官方教程</a>编写文章内容<span id="more"></span></li>
</ul>
<h1 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h1><ul>
<li><code>hexo n draft filename</code> – 在&#x2F;source&#x2F;_drafts文件夹下生成一个filename.md</li>
<li><code>hexo publish filename</code> – 发布文章，将md文件移动到&#x2F;source&#x2F;_posts下</li>
</ul>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><ul>
<li>为了实现结构化管理每篇博客的图像，将_config.yml中的post_asset_folder设置为true，并加入以下内容<img src="/2024/05/27/%E6%92%B0%E5%86%99%E5%8D%9A%E5%AE%A2/image2.png" class="" title="image2"></li>
<li>配置文件修改完成后，每次运行<code>hexo n filename</code>都会在&#x2F;source&#x2F;_posts文件夹下生成一个filename.md和一个&#x2F;filename文件夹</li>
<li>插入图片<ul>
<li>将需要加载的图片放入到与当前博客同名的文件夹下</li>
<li>在需要插入图片的位置插入以下代码 <code>&#123;% asset_img 随便什么名.png 想要插入的图片名 %&#125;</code>，即可在网页上加载出来</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
