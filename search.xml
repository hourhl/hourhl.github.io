<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AFL++的安装和基本使用</title>
    <url>/2024/09/07/AFL-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="AFL-简介"><a href="#AFL-简介" class="headerlink" title="AFL++简介"></a>AFL++简介</h1><h1 id="AFL-安装流程"><a href="#AFL-安装流程" class="headerlink" title="AFL++安装流程"></a>AFL++安装流程</h1><h1 id="AFL-基本使用（仅记录一下fuzz二进制程序的实验流程）"><a href="#AFL-基本使用（仅记录一下fuzz二进制程序的实验流程）" class="headerlink" title="AFL++基本使用（仅记录一下fuzz二进制程序的实验流程）"></a>AFL++基本使用（仅记录一下fuzz二进制程序的实验流程）</h1>]]></content>
      <tags>
        <tag>模糊测试</tag>
        <tag>AFL++</tag>
      </tags>
  </entry>
  <entry>
    <title>Gnutls源码安装小记</title>
    <url>/2024/08/20/Gnutls%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="源码安装Gnutls"><a href="#源码安装Gnutls" class="headerlink" title="源码安装Gnutls"></a>源码安装Gnutls</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>根据Gnutls仓库的<a href="https://gitlab.com/gnutls/gnutls">readme</a>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">apt-get install -y dash git-core autoconf libtool gettext autopoint</span><br><span class="line">apt-get install -y automake python3 nettle-dev libp11-kit-dev libtspi-dev libunistring-dev</span><br><span class="line">apt-get install -y libtasn1-bin libtasn1-6-dev libidn2-0-dev gawk gperf</span><br><span class="line">apt-get install -y libtss2-dev libunbound-dev dns-root-data bison gtk-doc-tools</span><br><span class="line">apt-get install -y texinfo texlive texlive-plain-generic texlive-extra-utils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译安装</span></span><br><span class="line">./bootstrap</span><br><span class="line">./configure --with-included-libtasn1 --with-included-unistring</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><ol>
<li><p><code>Libnettle x.x was not found</code> (x是一个版本的数字，比如Libnettle 3.6 was not found)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装nettle（源码安装或者sudo apt安装）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到pkgconfig文件夹，更新PKG_CONFIG_PATH路径，例如</span></span><br><span class="line">export PKG_CONFIG_PATH=&quot;/usr/local/lib64/pkgconfig:$PKG_CONFIG_PATH&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新编译</span> </span><br><span class="line">./configure --with-included-libtasn1 --with-included-unistring</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nettlex.so not found</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到nettlex.so的地址，手动设置共享库地址</span> </span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib64:$LD_LIBRARY_PATH</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新缓存</span></span><br><span class="line">echo &quot;/usr/local/lib64&quot; | sudo tee /etc/ld.so.conf.d/local-lib.conf</span><br><span class="line">sudo ldconfig</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新编译</span></span><br><span class="line">sudo make clean</span><br><span class="line">./configure --with-included-libtasn1 --with-included-unistring</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>./cha-config.texi:1: node System-wide configuration of the library&#39; lacks menu item for Enabling/Disabling RSAES-PKCS1-v1_5&#39; despite being its Up target</code> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make clean</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用文档生成</span></span><br><span class="line">./configure --with-included-libtasn1 --with-included-unistring --disable-doc</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>E: 无法定位软件包 texlive-plain-generic</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装其他类似的安装包</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install texlive-base</span><br></pre></td></tr></table></figure></li>
<li><p><code>libev4 was not found.</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libev4 libev-dev</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>Gnutls</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>StrongSwan部署小记</title>
    <url>/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="虚拟机搭建strongswan"><a href="#虚拟机搭建strongswan" class="headerlink" title="虚拟机搭建strongswan"></a>虚拟机搭建strongswan</h1><p>注：仅作测试用，故服务端和客户端分别安装在了同一网段下的两台Ubuntu上。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ul>
<li><p>操作系统</p>
<!-- ![image-20240816074401529](E:\lab\IPsec.assets\image-20240816074401529.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image1.png" class="" title="image1">
</li>
<li><p>配置环境</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libgmp-dev libssl-dev libcurl4-openssl-dev libsystemd-dev libjson-c-dev make gcc pkg-config libsystemd-dev</span><br></pre></td></tr></table></figure>

<ul>
<li><p>安装过程</p>
<ul>
<li><p>下载源码并编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://download.strongswan.org/strongswan-5.8.3.tar.gz</span><br><span class="line">tar xzf strongswan-5.8.3.tar.gz</span><br><span class="line">cd strongswan-5.8.3</span><br><span class="line">./configure --prefix=/usr --sysconfdir=/etc --enable-eap-identity --enable-eap-md5 --enable-eap-mschapv2 --enable-eap-tls --enable-eap-ttls --enable-eap-peap --enable-eap-tnc --enable-eap-dynamic --enable-eap-radius --enable-xauth-eap --enable-xauth-pam  --enable-dhcp  --enable-openssl  --enable-addrblock --enable-unity --enable-certexpire --enable-radattr --enable-swanctl --enable-openssl --disable-gmp --enable-systemd</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>安装成功</p>
<!-- ![image-20240816080528752](E:\lab\IPsec.assets\image-20240816080528752.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image2.png" class="" title="image2">
</li>
<li><p>生成CA证书和服务器证书</p>
<p>创建服务器证书时，–dn中的CN要填写本机的ip，–san同理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir genPem</span><br><span class="line">cd genPem</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建CA密钥</span></span><br><span class="line">ipsec pki --gen --outform pem &gt; ca-key.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建CA证书</span></span><br><span class="line">ipsec pki --self --in ca-key.pem --dn &quot;C=CN, O=My VPN, CN=My VPN CA&quot; --ca --outform pem &gt; ca-cert.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建服务器密钥</span></span><br><span class="line">ipsec pki --gen --outform pem &gt; server-key.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建服务器证书</span></span><br><span class="line">ipsec pki --pub --in server-key.pem | ipsec pki --issue --cacert ca-cert.pem --cakey ca-key.pem --dn &quot;C=CN, O=My VPN, CN=serverIp&quot; --san=&quot;serverIp&quot; --flag serverAuth --outform pem &gt; server-cert.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将证书和密钥放到正确的位置</span></span><br><span class="line">sudo cp ca-cert.pem /etc/ipsec.d/cacerts/</span><br><span class="line">sudo cp server-cert.pem /etc/ipsec.d/certs/</span><br><span class="line">sudo cp server-key.pem /etc/ipsec.d/private/</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置&#x2F;etc&#x2F;ipsec.secrets（这个文件似乎可有可无，稳妥起见还是加上吧）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">: RSA &quot;server-key.pem&quot;</span><br><span class="line">test : EAP &quot;test&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置&#x2F;etc&#x2F;swanctl&#x2F;conf.d&#x2F;192.168.139.129.conf（注意：此处的文件名为本机的ip.conf）</p>
<p>下面的配置文件中有文字注释的部分需要修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connections &#123;</span><br><span class="line">    ikev2-eap-mschapv2 &#123;</span><br><span class="line">        version = 2</span><br><span class="line">        unique = never</span><br><span class="line">        proposals = aes256-sha1-modp1024</span><br><span class="line">        # proposals = aes256-sha1-modp1024, aes128-sha1-modp1024, 3des-sha1-modp1024</span><br><span class="line">        # proposals = aes256-sha256-prfsha256-modp2048, aes256gcm16-prfsha384-modp1024, default</span><br><span class="line">        rekey_time = 0s</span><br><span class="line">        fragmentation = yes</span><br><span class="line">        dpd_delay = 30s</span><br><span class="line">        send_cert = always</span><br><span class="line">        local_addrs = %any</span><br><span class="line">        local &#123;</span><br><span class="line">            certs = server-cert.pem</span><br><span class="line">            # 服务器ip</span><br><span class="line">            id = 192.168.139.129</span><br><span class="line">        &#125;</span><br><span class="line">        remote &#123;</span><br><span class="line">            auth = eap-mschapv2</span><br><span class="line">            eap_id = %any</span><br><span class="line">            # request_virtual_ip = no</span><br><span class="line">        &#125;</span><br><span class="line">        children &#123;</span><br><span class="line">            ikev2-eap-mschapv2 &#123;</span><br><span class="line">                local_ts = 0.0.0.0/0,::/0</span><br><span class="line">                remote_ts = 0.0.0.0/0</span><br><span class="line">                rekey_time = 0s</span><br><span class="line">                dpd_action = clear</span><br><span class="line">                esp_proposals = aes256-sha256, aes128-sha1, default</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">secrets &#123;</span><br><span class="line">    private-www &#123;</span><br><span class="line">        file = server-key.pem</span><br><span class="line">    &#125;</span><br><span class="line">    # id为用户名，secret为密码</span><br><span class="line">    eap-test &#123;</span><br><span class="line">        id = test</span><br><span class="line">        secret = &quot;123456&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>启动服务</p>
<p>注：直接启动strongswan时会有一个报错，提示没有这个service，直接把报错信息复制给GPT就行，我也忘记具体的指令了，就是创建一个文件使其能启动strongswan ipsec</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable strongswan</span><br><span class="line">sudo systemctl start strongswan</span><br><span class="line">sudo systemctl status strongswan</span><br></pre></td></tr></table></figure>

<!-- ![image-20240816083736097](E:\lab\IPsec.assets\image-20240816083736097.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image3.png" class="" title="image3"></li>
</ul>
</li>
</ul>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul>
<li>操作系统</li>
</ul>
<!-- ![image-20240816100339589](E:\lab\IPsec.assets\image-20240816100339589.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image4.png" class="" title="image4">

<ul>
<li><p>直接命令行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install strongswan</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 &#x2F;etc&#x2F;ipsec.conf</p>
<p>带文字注释的要修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config setup</span><br><span class="line">    charondebug=&quot;ike 2, knl 2, cfg 2&quot;</span><br><span class="line"></span><br><span class="line">conn %default</span><br><span class="line">    keyexchange=ikev2</span><br><span class="line">    ike=aes256-sha1-modp1024</span><br><span class="line">    esp=aes256-sha1</span><br><span class="line">    dpdaction=clear</span><br><span class="line">    dpddelay=300s</span><br><span class="line">    rekey=no</span><br><span class="line"></span><br><span class="line">conn ikev2-vpn</span><br><span class="line">    left=192.168.139.129 # 服务器ip</span><br><span class="line">    leftid=192.168.139.129 # 服务器ip</span><br><span class="line">    leftauth = pubkey</span><br><span class="line">    leftcert=server-cert.pem</span><br><span class="line">    leftsendcert=always</span><br><span class="line">    leftsubnet=192.168.139.0/24 # 两台机器所在的网段</span><br><span class="line">    right=192.168.139.130 # 本机ip</span><br><span class="line">    rightid=192.168.139.130 # 本机ip</span><br><span class="line">    rightsubnet=0.0.0.0/0</span><br><span class="line">    rightauth=eap-mschapv2</span><br><span class="line">    rightsendcert=never</span><br><span class="line">    eap_identity=test</span><br><span class="line">    auto=add</span><br></pre></td></tr></table></figure>
</li>
<li><p>证书和私钥</p>
<p>把在服务端生成的对应文件也放到客户端对应的目录下</p>
<!-- ![image-20240820171519672](E:\lab\strongswan\strongswan安装文档.assets\image-20240820171519672.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image5.png" class="" title="image5">
</li>
<li><p>配置<code>/etc/ipsec.secrets</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test : EAP &quot;test&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ipsec restart</span><br><span class="line">sudo ipsec up ikev2-vpn</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><p>客户端</p>
<!-- ![image-20240820165034674](E:\lab\IPsec.assets\image-20240820165034674.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image6.png" class="" title="image6">

<p>服务端</p>
<!-- ![image-20240820165401813](E:\lab\IPsec.assets\image-20240820165401813.png) -->
<img src="/2024/08/20/StrongSwan%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/image7.png" class="" title="image7">]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>Strongswan</tag>
        <tag>IPsec</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/2024/05/23/Welcome/</url>
    <content><![CDATA[<p>Welcome to hourhl’s blog! </p>
]]></content>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》(一)</title>
    <url>/2024/05/24/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="客户端-服务器架构"><a href="#客户端-服务器架构" class="headerlink" title="客户端&#x2F;服务器架构"></a>客户端&#x2F;服务器架构</h2><ul>
<li>mysqld：MySQL服务器程序，运行该程序可以启动一个服务器进程</li>
<li>mysql：MySQL客户端程序，运行该程序可以发送请求并接收服务器的处理结果 </li>
<li>客户端与服务器的连接<span id="more"></span>
<ul>
<li>本质：进程间通信</li>
<li>网络通信协议：TCP&#x2F;IP</li>
<li>服务器默认端口：3306</li>
<li>服务器处理的流程：连接管理 -&gt; 解析与优化 -&gt; 存储引擎<ul>
<li><strong>连接管理</strong>：客户端可以携带主机信息、用户名与密码等信息，采用TCP&#x2F;TP、命名管道或者共享内存、UNIX套接字等方式连接服务端。每当有客户端信息验证通过，连接到服务器端进程时，服务器端就会创建一个线程进行交互；当通信结束后，并不会立即销毁该线程，而是缓存起来，当有新的客户端连接时，将这个线程分配给新的客户端</li>
<li><strong>解析与优化</strong>：查询缓存 -&gt; 语法解析 -&gt; 查询优化<ol>
<li>查询缓存 – 同样的请求会从缓存中查找结果，但是如果两个请求有任何字符上的不同，都会重新计算</li>
<li>查询优化 – 优化的结果是生成一个执行计划，可以通过<code>explain</code>来查看</li>
</ol>
</li>
<li><strong>存储引擎</strong>：默认引擎是InnoDB</li>
</ul>
</li>
<li>实现效果：客户端向服务器发送一段文本（SQL语句），服务器进程处理后再向客户端返回一段文本</li>
</ul>
</li>
</ul>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><ul>
<li>启动选项<ul>
<li>命令行修改<br><code>仅对当次启动生效</code> </li>
<li>配置文件修改<br><code>无论是Linux系统还是Windows系统，都有多个对应的配置文件查找路径，且路径之间有优先级</code></li>
</ul>
</li>
<li>系统变量<ul>
<li>系统变量有不同的作用范围，包括GLOBAL和SESSION</li>
<li>大部分的系统变量可以当作启动项来设置，但是有些系统变量是程序运行过程中自动生成，无法修改</li>
</ul>
</li>
</ul>
<h2 id="字符集和比较规则"><a href="#字符集和比较规则" class="headerlink" title="字符集和比较规则"></a>字符集和比较规则</h2><ul>
<li>将字符映射成二进制称为编码，反之为解码。人们抽象出一个字符集的概念来描述某个字符范围的编码规则<br><code>常见字符集：ASCII、ISO8859-1、GB2312等</code></li>
<li>每个字符集有多个比较规则，比如是否区分重音、是否区分大小写等</li>
</ul>
<h2 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h2><h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><ul>
<li>MySQL会将数据存放到数据目录下，可以在客户端<code>show variables like &#39;datadir&#39;</code>来查看数据目录</li>
<li>数据目录中存放着系统数据库、用户自定义的数据库以及一些系统相关文件<blockquote>
<ul>
<li><code>mysql</code> 系统数据库，在数据目录下有对应的子文件夹。该数据库存储MySQL的用户账户和权限信息、一些存储过程和事件的定义信息、一些运行过程中产生的日志信息、一些帮助信息以及时区信息等。</li>
<li><code>performance_schema</code> 系统数据库，在数据目录下有对应的子文件夹。该数据库主要保存MySQL服务器运行过程中的状态信息，包括统计最近执行了哪些语句、在执行过程的每个阶段花费了多长时间、内存的使用情况等。</li>
<li><code>information_schema</code> 系统数据库，在数据目录下<strong>没有</strong>对应的文件夹。该数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、视图、触发器、列、索引等。并不是真实的数据，而是以描述性信息的形式存在，也称之为元数据。</li>
<li><code>sys</code> 系统数据库，在数据目录下有对应的文件夹。主要通过视图的形式把information_schema和performance_schema结合起来，让开发人员更方便地了解MySQL服务器的性能。</li>
<li><code>用户数据库</code> 用户自定义的数据库，在数据目录下有对应的子文件夹。详细信息见下文。</li>
<li><code>服务器进程文件</code> 一个服务器程序对应着一个进程，该文件存储着相关的进程ID</li>
<li><code>服务器日志文件</code> 包括查询日志、错误日志、二进制日志、redo日志等</li>
<li><code>SSL和RSA证书与密钥文件</code></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="用户数据库"><a href="#用户数据库" class="headerlink" title="用户数据库"></a>用户数据库</h3><ul>
<li>当用户创建了一个数据库，系统就会在数据目录下创建一个同名的文件夹，并且在这个文件夹中生成一个名为dp.opt的文件，该文件存储了数据库的相关信息，包括字符集、比较规则等。</li>
<li>每个数据库对应的子文件夹都有一个描述表结构的文件，名称为<strong>表名.frm</strong>。另外，不同的存储引擎会采用不同的方式存储数据。（即每个数据库对应的子文件夹下有两类文件，一类是描述表结构的文件，一类是数据文件）<ol>
<li><code>InnoDB</code> 在该引擎中，索引和用户记录都是当作数据来处理。数据存放在数据页中，采用表空间来管理数据页。表空间又包括多种类型，比如系统表空间和独立表空间<ol>
<li><code>系统表空间</code> InnoDB会在文件目录下创建一个名为<strong>ibdata1</strong>，大小为12MB的文件（当容量不够时会自扩展）</li>
<li><code>独立表空间</code> 在MySQL5.6.6及以后的版本中，默认把数据存放到独立表空间中。每当建立一个新的表，就会创建一个新的独立表空间，其文件名是<strong>表名.ibd</strong>，存放在该表所属的数据库的子文件夹下。</li>
</ol>
</li>
<li><code>MyISAM</code> 在该引擎中，索引和用户记录是分开存放的。其对应的子文件夹下有三类文件，分别是记录表结构的<strong>表名.ibd</strong>、记录用户记录的<strong>表名.MYD</strong>以及记录索引的<strong>表名.MY1</strong>.</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》（二）</title>
    <url>/2024/08/03/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><code>MySQL中有不同的存储引擎，其存储方式均有所不同，以下仅以InnoDB引擎为例</code></p>
<ul>
<li><strong>读取方式：页</strong> InnoDB将数据库中的数据划分为若干页，每次进行数据存取是都以页为单位，页的大小是16KB.每一个页面上以记录的形式存放着相关数据，每条记录又可分为真实数据、额外数据和隐藏列（以COMPACT行格式为例），额外数据是用来辅助存储和读取信息的，包括变长字段长度列表、NULL值列表和记录头信息。<span id="more"></span>
<ol>
<li><p><strong>变长字段长度列表</strong> 常见的变长字段类型包括VARCHAR、TEXT类型等，这些数据类型的长度是不固定的，为了从记录中准确读取它的内容，就需要记录它所占据的字节数。</p>
<ul>
<li>变长字段的长度是按逆序存放的。例如变长字段1占据3字节，字段2占据8字节，则变长字段长度列表的存放就是0x080x03。</li>
<li>假设某个字段L是VARCHAR(m)类型，采用的字符集最多需要使用w字节来表示一个字符，且其真实占用的字节数是L。当m×w的乘积结果小于等于255，则其只需要用1个字节来存放它的长度；当乘积结果大于255且L也大于127，则需要用2两个字节来存放它的长度，否则用1个字节即可。</li>
<li>变长字段长度列表只存储值为非NULL的变长字段列。</li>
</ul>
</li>
<li><p><strong>NULL值列表</strong> 该列表仅在表中允许存储NULL值的列存在的时候存在。其值等同于对应列按整数个字节逆序存放，并且用二进制表示。例如有三个列允许NULL值存在，且仅有第二和第三列为NULL，则其对应的NULL值列表的二进制表示为00000110。由于仅有三个列，需要1个字节来存放即可，高位用0补全，同时考虑到第二和第三列为NULL，正常情况为<code>0</code> <code>1</code> <code>1</code>，根据COMPACT行格式的存放规则，需要逆序存放，故得到的结果为00000110，即0x06。</p>
</li>
<li><p><strong>记录头信息</strong> 该部分固定由5字节组成，用于描述记录的一些属性。此处仅列出比较重要的字段，不再多做赘述，可以查找资料了解即可。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">大小（bit）</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n_owned</td>
<td align="center">4</td>
<td align="center">组中的领头节点记录该组中的记录条数</td>
</tr>
<tr>
<td align="center">deleted_flag</td>
<td align="center">1</td>
<td align="center">标记该记录是否被删除</td>
</tr>
<tr>
<td align="center">min_rec_flag</td>
<td align="center">1</td>
<td align="center">B+树中每层非叶子节点的最小的目录项</td>
</tr>
<tr>
<td align="center">heap_no</td>
<td align="center">13</td>
<td align="center">当前记录在堆中的相对位置</td>
</tr>
<tr>
<td align="center">record_type</td>
<td align="center">3</td>
<td align="center">当前记录的类型</td>
</tr>
<tr>
<td align="center">next_record</td>
<td align="center">16</td>
<td align="center">下一条记录的位置</td>
</tr>
</tbody></table>
</li>
<li><p><strong>隐藏列</strong> 包括row_id、trx_id和roll_pointer。row_id非必须，只有表中没有定义主键，也没有不允许存储NULL值的UNIQUE键时，才会添加该字段,占用6字节。trx_id时必须的，占用6字节，属于事务id。roll_pointer也是必须的，占用7字节，用于进行事务回滚。</p>
</li>
</ol>
</li>
<li><strong>溢出列</strong> 当某条记录所占空间过大时，在记录的真实数据处只会存放该字段的部分数据，然后用20字节指向剩余数据存放页的位置。</li>
</ul>
<h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><ul>
<li><p>数据页大小为16KB，主要可以分为七大部分，分别是<code>File Header</code> \ <code>Page Header</code> \ <code>Infimum + Supremum</code> \ <code>User Records</code> \ <code>Fres Space</code> \ <code>Page Directory</code> \ <code>File Trailer</code>.</p>
<table>
<thead>
<tr>
<th align="center">模块</th>
<th align="center">占用空间（字节）</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">文件头</td>
<td align="center">38</td>
<td align="center">页的通用信息</td>
</tr>
<tr>
<td align="center">页面头</td>
<td align="center">56</td>
<td align="center">数据页的专有信息</td>
</tr>
<tr>
<td align="center">页面的最大记录和最小记录</td>
<td align="center">26</td>
<td align="center">两个虚拟记录</td>
</tr>
<tr>
<td align="center">数据（用户记录）</td>
<td align="center">不定</td>
<td align="center">用户存储的数据</td>
</tr>
<tr>
<td align="center">空白区域</td>
<td align="center">不确定</td>
<td align="center">页面中尚未使用的空间</td>
</tr>
<tr>
<td align="center">页目录</td>
<td align="center">不确定</td>
<td align="center">页面中某些记录的相对位置</td>
</tr>
<tr>
<td align="center">文件尾</td>
<td align="center">8</td>
<td align="center">校验页的完整性</td>
</tr>
</tbody></table>
</li>
<li><p>数据相关操作</p>
<ul>
<li><strong>增</strong> - 往用户记录空间插入一条记录<ol>
<li>每个页中都有两条默认插入的记录，分别是最小记录Infimum和最大记录Supremum，记录的大小通过主键的大小来确定，这两条是默认最大和最小的，但这两条记录存放在用户记录区域的靠前部分。</li>
<li>页面中所有记录都会分组，Infimum所在的组只能有1条记录，即它自己，Supremum所在的记录数量限制在1-8条，其余组的记录数量限制在4-8条。新增的记录从最近的比它大的记录所在的组开始插入。当组中记录的数量达到9条，从中间划分，生成一个新的组，前一个组的大小为4，后一个组的大小为5。</li>
</ol>
</li>
<li><strong>删</strong> - 从用户记录空间删除一条记录<ol>
<li>被删除的记录并不会直接从磁盘中删除，而是修改deleted_flag，其值为1时表示被删除，同时修改其next_record值为1，表示没有下一条记录。</li>
<li>所有被删除的记录会组成一个垃圾链表，按照主键由小到大的顺序链接，这些链表占用的空间被称为可重用空间。</li>
</ol>
</li>
<li><strong>查</strong> - 从用户记录空间查询一条记录<ol>
<li>每一组中最后一条记录的真实数据与该页开头的偏移量称为槽，按照组的逆序排列在页目录中，且从靠近文件尾的部分开始存储，每个槽占用2个字节。<img src="/2024/08/03/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/datatype-structure.png" class="" width="200" title="datatype-structure"></li>
<li>按照二分法，low &#x3D; 槽0， high &#x3D; 槽n,先计算中间的槽的主键值（对应该组中最大的记录的主键值），然后修改low或者high。直到确认目标主键在哪一组中，遍历该组即可。（每一组最多只有8条记录，遍历速度很快）</li>
</ol>
</li>
</ul>
</li>
<li><p>记录头信息</p>
<ol>
<li>n_owned : 每个页面中的记录会分为若干个组，组内最大的记录会记录该组内有多少条记录</li>
<li>heap_no : 存放在页面前面的记录heap_no值偏小，每新生成一条记录的存储空间，其值都比物理位置在它前面的那条记录的heap_no值大1。heap_no从2开始，因为0和1分别指代了Infimum和Supremum。</li>
<li>record_type : 0表示普通记录，1表示B+树非叶子节点的目录项记录，2表示Infimum，3表示Supremum。</li>
<li>next_record ： 当前记录的数据部分到下一条记录的数据部分。注意每条记录由记录头部分和数据部分组成，这个指向的是数据部分的开头，这样的好处是向后可以遍历数据，向前可以遍历该记录的记录头。当这个值为正数，说明下一条记录（指按主键排列的下一条记录，不是插入顺序的下一条记录）在当前记录的后面，反之在前面。规定Infimum记录的下一条记录就是当前页面主键值最小的记录，Supremum记录的next_record值为0，表示没有下一条记录。</li>
</ol>
</li>
<li><p>页面头<br>页面头是页结构的第二部分，占用56字节，其各个部分的作用如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">占用空间（字节）</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td align="center">页目录中的槽数量</td>
</tr>
<tr>
<td align="center">PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td align="center">空闲空间起始地址</td>
</tr>
<tr>
<td align="center">PAGE_N_HEAP</td>
<td align="center">2</td>
<td align="center">前1比特表示本记录是否为紧凑型的记录，后15bit表示本页中记录的数量，包括Infimum和Supremum，以及删除的记录）</td>
</tr>
<tr>
<td align="center">PAGE_FREE</td>
<td align="center">2</td>
<td align="center">已删除的记录链表中起始记录所在的偏移地址</td>
</tr>
<tr>
<td align="center">PAGE_GARBAGE</td>
<td align="center">2</td>
<td align="center">已删除的记录占用的字节数</td>
</tr>
<tr>
<td align="center">PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td align="center">最后插入的记录的位置</td>
</tr>
<tr>
<td align="center">PAGE_DIRECTION</td>
<td align="center">2</td>
<td align="center">记录插入的方向（新插入的记录的主键比上一条大或者小，前者认为是向右，否则向左）</td>
</tr>
<tr>
<td align="center">PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td align="center">一个方向连续插入的记录数量（仅记录最新值）</td>
</tr>
<tr>
<td align="center">PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td align="center">修改当前页的最大事务id，该值仅在二级索引页面中定义</td>
</tr>
<tr>
<td align="center">PAGE_LEVEL</td>
<td align="center">2</td>
<td align="center">当前页在B+树中所处的层级</td>
</tr>
<tr>
<td align="center">PAGE_INDEX_ID</td>
<td align="center">8</td>
<td align="center">当前页属于的索引id</td>
</tr>
<tr>
<td align="center">PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td align="center">B+树叶子节点段的头部信息，仅在B+树的根页面中定义</td>
</tr>
<tr>
<td align="center">PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td align="center">B+树非叶子节点段的头部信息，仅在B+树的根页面中定义</td>
</tr>
</tbody></table>
</li>
<li><p>文件头<br>文件头是页结构的第一部分，占用38字节，其各个部分的作用如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">占用空间（字节）</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FIL_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td align="center">在MySQL4.0.14之后的版本中，该属性表示页的校验和</td>
</tr>
<tr>
<td align="center">FIL_PAGE_OFFSET</td>
<td align="center">4</td>
<td align="center">页号</td>
</tr>
<tr>
<td align="center">FIL_PAGE_PREV</td>
<td align="center">4</td>
<td align="center">上一页的页号</td>
</tr>
<tr>
<td align="center">FIL_PAGE_NEXT</td>
<td align="center">4</td>
<td align="center">下一页的页号</td>
</tr>
<tr>
<td align="center">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td align="center">页面被最后修改时对应的LSN值（Log Sequence Number,日志序列号）</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE</td>
<td align="center">2</td>
<td align="center">该页的类型</td>
</tr>
<tr>
<td align="center">FIL_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td align="center">仅在系统表空间的第一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td align="center">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td align="center">页属于哪个表空间</td>
</tr>
</tbody></table>
<p>其中FIL_PAGE_TYPE表示某个页面的类型，包括日志页、溢出页等，其可能的值见下表。</p>
<table>
<thead>
<tr>
<th align="center">类型名称</th>
<th align="center">值</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FIL_PAGE_TYPE_ALLOCATED</td>
<td align="center">0x0000</td>
<td align="center">新分配未使用</td>
</tr>
<tr>
<td align="center">FIL_PAGE_UNDO_LOG</td>
<td align="center">0x002</td>
<td align="center">undo日志页</td>
</tr>
<tr>
<td align="center">FIL_PAGE_INODE</td>
<td align="center">0x003</td>
<td align="center">存储段信息</td>
</tr>
<tr>
<td align="center">FIL_PAGE_IBUF_FREE_LIST</td>
<td align="center">0x004</td>
<td align="center">Change Buffer空闲列表</td>
</tr>
<tr>
<td align="center">FIL_PAGE_IBUF_BITMAP</td>
<td align="center">0x005</td>
<td align="center">Change Buffer的属性</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_SYS</td>
<td align="center">0x006</td>
<td align="center">系统数据</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_TRX_SYS</td>
<td align="center">0x007</td>
<td align="center">事务系统数据</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_FSP_HDR</td>
<td align="center">0x008</td>
<td align="center">表空间头部信息</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_XDES</td>
<td align="center">0x009</td>
<td align="center">存储区的属性</td>
</tr>
<tr>
<td align="center">FIL_PAGE_TYPE_BLOB</td>
<td align="center">0x00A</td>
<td align="center">溢出页</td>
</tr>
<tr>
<td align="center">FIL_PAGE_INDEX</td>
<td align="center">0x45BF</td>
<td align="center">索引页，也就是我们说的数据页</td>
</tr>
</tbody></table>
</li>
<li><p>文件尾</p>
<ol>
<li>文件尾是页的最后一部分，占用8个字节。主要用于进行页面的校验。</li>
<li>文件尾的前4个字节是该页面的校验和，正常情况下其值等于文件头中的校验和。如果该页面被修改，会重新计算这两个部分的校验和。当该页面被刷新到磁盘中时，由于文件头在前，其值会被先写入磁盘。如果刷新页面的过程中发生了断电，重启服务后只需比较页面中的两个校验和即可，如果两个校验和相等，说明该页刷新成功，否则说明该页在刷新过程中发生了错误。</li>
<li>文件尾的后四个字节表示最后修改时对应的LSN的值，正常情况下与文件头中的FILE_PAGE_LSN相等。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》（四）</title>
    <url>/2024/09/06/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><ol>
<li>MySQL执行查询语句的方式称为访问方法或者访问类型。同一个查询语句可以有多个访问方法来执行，不同访问方法进行查询的结果保持一致，但是所需的成本不同。</li>
<li><strong>const</strong> 通过主键或者唯一二级索引列与常数的等值比较的访问方法。如果主键或者二级索引是由多个列来组成，则必须每一列都进行等值比较。<blockquote>
<ul>
<li>该访问方法被认为是常数级别的</li>
<li>利用二级索引进行查询，并且查询条件为NULL时，不采用const访问方法。</li>
</ul>
</blockquote>
</li>
<li><strong>ref</strong> 通过二级索引列与常数进行等值比较，并且形成的扫描区间为单点扫描区间的访问方法。<blockquote>
<ul>
<li>采用二级索引来进行查询时，每找到一条符合条件的二级索引，都会立即回表查询，而不是得到所有的主键id再统一进行回表。</li>
<li>当查询的值为NULL时，最多只能使用ref查询方法。</li>
<li>对于索引列中包含多个列的索引来说，只要左边的列与常数进行等值比较，都可以用ref，如果是范围比较，就不能用ref。</li>
</ul>
</blockquote>
</li>
<li><strong>ref_or_null</strong> 比ref方法多了搜索条件为NULL。<blockquote>
<ul>
<li>值为NULL的记录会被放在索引树的最左边</li>
</ul>
</blockquote>
</li>
<li><strong>range</strong> 使用索引查询时，对应的扫描区间为若干个单点扫描区间或者范围扫描区间的单表访问方法。</li>
<li><strong>index</strong> 扫描全部二级索引记录的访问方法。<blockquote>
<ul>
<li>index访问方法的应用场景可以如下：查询结果是覆盖索引中对应的列，但是搜索条件不是按索引列的从左到右来的，可能是中间某个列或者某几个列。但是由于所要的结果在索引中已经存在，不需要再次回表查询了，仅需要扫描该索引即可。</li>
</ul>
</blockquote>
</li>
<li><strong>all</strong> 执行全表扫描的访问方法。</li>
</ol>
<h3 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h3><ol>
<li><strong>索引合并</strong> 使用多个索引来完成一次查询的方法</li>
<li><strong>Intersection索引合并</strong> 利用不同的索引分别进行扫描，得到的结果取交集，再利用得到的结果来进行回表。<blockquote>
<p>要求使用二级索引的必须是等值查询，并且如果是联合索引，要求每一个索引列都要覆盖。原因：当二级索引的值相同时，叶子节点是根据主键排列的，便于取交集，并且在后续回表的过程中更有利于读取信息，而不是随机I&#x2F;O。<br>select * from table where key1 &#x3D; 10 and key2 &#x3D; 20;</p>
</blockquote>
</li>
<li><strong>Union索引合并</strong> 利用不同的索引分别进行扫描，得到的结果取并集，再利用得到的结果来进行回表。<blockquote>
<p>同样要求用二级索引的必须是等值查询，并且如果是联合索引，要求每一个索引列都要覆盖。原因：便于取并集，回表时的效率也高。<br>select * from table where key1 &#x3D; 10 or key2 &#x3D; 20;</p>
</blockquote>
</li>
<li><strong>sort-union索引合并</strong> 利用不同索引分别进行扫描，得到结果先排序再取并集。<blockquote>
<p>不要求二级索引必须等值查询，也不要求联合索引的每一个列都得是等值查询<br>select * from table where key1 &gt; 10 and index_part1 &#x3D; 1;</p>
</blockquote>
</li>
</ol>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><ul>
<li>连接的本质就是把各个表中的记录都取出来进行一次匹配，并把匹配后的组合发送给客户端</li>
<li><strong>驱动表</strong>即第一个需要查询的表，再根据驱动表到被<strong>驱动表</strong>中找匹配的记录。也就是说，驱动表只需要访问一次，被驱动表可能需要访问多次。每获得一条驱动表记录，都需要到被驱动表中寻找匹配的记录。</li>
</ul>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><ul>
<li>对于进行内连接查询的表，如果驱动表中的记录在被驱动表中没找到对应的，那就不会加入结果集中。</li>
<li>内连接的查询基本步骤如下<ol>
<li>选取驱动表，适用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询</li>
<li>对步骤1中查询驱动表中得到的结果集中的每一条记录，都分别到被驱动表中查找匹配的记录。</li>
</ol>
</li>
</ul>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><ul>
<li>对于进行外连接查询的表(包括左外连接和右外连接)，即使驱动表中的记录在被驱动表中没找到对应的，还是会加入到结果集。</li>
<li>左外连接 - 选择左侧的表为驱动表</li>
<li>右外连接 - 选择右侧的表为驱动表<blockquote>
<p>where子句中不符合条件的记录，不管是外连接还是内连接，都不会加入结果集。<br>on子句的处理方式就很符合内外连接的区别。如果不符合条件，在内连接中就不会加入结果集，但是在外连接中会加入结果集。</p>
</blockquote>
</li>
</ul>
<h1 id="计算成本"><a href="#计算成本" class="headerlink" title="计算成本"></a>计算成本</h1><ul>
<li>一条查询语句的执行成本包括I&#x2F;O成本和CPU成本。前者指把记录从磁盘加载到内存中的时间，后者指读取记录、判断记录是否满足搜索条件、对结果进行排序等操作所损耗的时间。</li>
<li>成本常数<ul>
<li>读取一个页面的成本默认为1.0</li>
<li>检测一个记录是否符合搜索条件的成本默认是0.2</li>
</ul>
</li>
</ul>
<h2 id="单表查询成本"><a href="#单表查询成本" class="headerlink" title="单表查询成本"></a>单表查询成本</h2><ul>
<li>执行一条查询语句的基本步骤<ol>
<li>根据搜索条件，查找所有能用的索引</li>
<li>计算全表扫描的成本</li>
<li>计算使用各种索引的成本</li>
<li>对比各种执行方案的代价，选择成本最低的方案</li>
</ol>
</li>
</ul>
<h2 id="连接查询成本"><a href="#连接查询成本" class="headerlink" title="连接查询成本"></a>连接查询成本</h2>]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>查询</tag>
      </tags>
  </entry>
  <entry>
    <title>《MySQL是怎样运行的》（三）</title>
    <url>/2024/08/14/%E3%80%8AMySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>常用的数据结构 - B+树</p>
<ol>
<li>高度平衡：所有叶子节点处于同一层</li>
<li>叶子节点存储索引列和主键值（或索引列和完整数据记录），由双向链表构成</li>
<li>除了叶子节点外，每个节点可以有多个子节点</li>
</ol>
</li>
<li><p>常见的索引类型</p>
<ul>
<li>按叶子节点存放的数据分类：聚簇索引（叶子节点存放完整的数据记录，通常主键作为排序条件）和二级索引（需要回表查询完整的数据记录，通常非主键列作为排序条件）</li>
<li>覆盖索引：需要查询的内容包含在索引列中</li>
<li>联合索引：也称复合索引、组合索引，该类型的索引包含了多个数据列，本质也是一个二级索引</li>
</ul>
</li>
<li><p>MyISAM引擎的细节和上述（InnoDB引擎）不完全一样。其将索引和数据分开存储。</p>
<blockquote>
<p>所有数据都存放在数据文件中，索引树存放对应的行号，根据行号查找对应的数据记录</p>
</blockquote>
</li>
</ul>
<h2 id="索引的构建及使用"><a href="#索引的构建及使用" class="headerlink" title="索引的构建及使用"></a>索引的构建及使用</h2><ul>
<li>InnoDB默认为主键构建一个聚簇索引，叶子节点包含完整的数据记录</li>
<li>用户可以为非主键构建二级索引，该B+树的非叶子节点存放索引列的值、主键值以及对应下一层索引页的页号，叶子节点存放索引列的值和主键值，需要根据主键值再去聚簇索引查找完整的数据记录，因此被称为二级索引</li>
<li>索引在逻辑层面上是B+树，在物理层面上是以页的形式存放，每一页都是同一层的节点，且页与页之间有双向指针相连。页内按照索引列的值大小排成单向链表。</li>
<li>索引页的布局与数据页类似，每一页都分成七个部分，其中数据部分分成若干组，每组中主键大的记录的偏移量会被存储在页目录中的槽中。</li>
<li>进行检索时，每条索引指向与其值相等的第一条记录所在的位置。</li>
</ul>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>提高查找效率</li>
<li>如果查找的结果需要按照索引条件分组或者排列，也能减少时间开支</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>维护索引需要额外的时间，比如插入数据导致的页面分裂，删除数据导致的索引重新排列等。</li>
<li>使用索引也需要时间。每次执行查询语句之前，都需要计算不同的索引所需的时间成本，生成一个执行计划。如果索引过多，就有可能导致这个生成执行计划的时间过长。</li>
<li>建立索引需要占用额外的空间。每创建一个索引就是构建一个新的二叉树，二叉树的节点需要占据空间。</li>
</ol>
<h2 id="如何创建合适的索引"><a href="#如何创建合适的索引" class="headerlink" title="如何创建合适的索引"></a>如何创建合适的索引</h2><ul>
<li><code>为常用作搜索条件的列创建索引</code>  为常出现在WHERE、ORDER BY、GROUP BY子句中的列创建索引，仅出现在查询列表中的列就不必要创建索引</li>
<li><code>不为含有太多重复值的列创建索引</code>  如果某列中重复的数值很多，该列就不适合作为快速搜索的条件，因此不必要创建索引</li>
<li><code>索引列的数据类型占用空间尽可能小</code>  为某列创建索引，索引树的节点中就都存放有该列的值，如果值的类型占用的存储空间太大，就会产生不必要的空间消耗。例如使用INT类型就足够表示，就不必要使用BIGINT类型。</li>
<li><code>为列前缀创建索引</code>  可以将字符串中的前几个字符存放到索引中。</li>
<li><code>创建覆盖索引</code>  常出现在查询列表中的列可以创建覆盖索引，这样B+树中的叶子节点就有需要的结果，不需要回表查询，减少时间开销。</li>
<li><code>不要在搜索条件中进行索引列的运算</code>  例如以key列创建了索引，如果WHERE子句中的搜索条件是WHERE key * 2 &lt; 4，那么MySQL将使用全表扫描而不使用索引。</li>
<li><code>表的主键设置为自动递增</code>  MySQL默认为表格的主键列创建聚簇索引，如果主键不是递增的，那么插入新记录时就有可能导致正好插入到已满的数据页的中间，此时MySQL需要进行页面分裂，并把一些数据移动到新的页面中，造成无谓的性能损耗。</li>
<li><code>不要创建冗余和重复索引</code>  例如本身已经创建了一个针对key1\key2的联合索引，就不需要单独再为key1创建索引了</li>
</ul>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>撰写博客(Hexo + Github)</title>
    <url>/2024/05/27/%E6%92%B0%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="新建md文件"><a href="#新建md文件" class="headerlink" title="新建md文件"></a>新建md文件</h1><ul>
<li><code>hexo n filename</code> – 在&#x2F;source&#x2F;_posts文件夹下生成一个filename.md<img src="/2024/05/27/%E6%92%B0%E5%86%99%E5%8D%9A%E5%AE%A2/image1.png" class="" title="image1"></li>
<li>参照<a href="https://markdown.com.cn/basic-syntax/">Markdown 官方教程</a>编写文章内容<span id="more"></span></li>
</ul>
<h1 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h1><ul>
<li><code>hexo n draft filename</code> – 在&#x2F;source&#x2F;_drafts文件夹下生成一个filename.md</li>
<li><code>hexo publish filename</code> – 发布文章，将md文件移动到&#x2F;source&#x2F;_posts下</li>
</ul>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><ul>
<li>为了实现结构化管理每篇博客的图像，将_config.yml中的post_asset_folder设置为true，并加入以下内容<img src="/2024/05/27/%E6%92%B0%E5%86%99%E5%8D%9A%E5%AE%A2/image2.png" class="" title="image2"></li>
<li>配置文件修改完成后，每次运行<code>hexo n filename</code>都会在&#x2F;source&#x2F;_posts文件夹下生成一个filename.md和一个&#x2F;filename文件夹</li>
<li>插入图片<ul>
<li>将需要加载的图片放入到与当前博客同名的文件夹下</li>
<li>在需要插入图片的位置插入以下代码 <code>&#123;% asset_img 随便什么名.png 想要插入的图片名 %&#125;</code>，即可在网页上加载出来</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客(Hexo + Github)</title>
    <url>/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>参考<br><a href="https://cloud.tencent.com/developer/article/2337246">使用Hexo从0到1搭建个人博客详细教程（超详细，超简单）</a><br><a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细）</a><br><a href="https://goldstine.github.io/create_blog_with_github_pages/">可能是最全面的github pages搭建个人博客教程</a></p>
<span id="more"></span>

<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><ul>
<li>安装node.js</li>
<li>配置npm安装的默认目录，并安装webpack<!-- ![](/_posts/搭建个人博客/image1.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image1.png" class="" title="image1"></li>
<li>安装博客网站的框架Hexo<ul>
<li>在Github新建一个仓库</li>
<li>本地新建一个Blog文件夹，在该目录下打开Git Bash，输入npm命令安装Hexo<!-- ![](/source/_posts/搭建个人博客/image2.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image2.png" class="" title="image2"></li>
<li>初始化博客<!-- ![](/source/_posts/搭建个人博客/image3.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image3.png" class="" title="image3"></li>
<li>静态部署<!-- ![](/source/_posts/搭建个人博客/image4.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image4.png" class="" title="image4"></li>
<li>启动服务器<!-- ![](/source/_posts/搭建个人博客/image5.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image5.png" class="" title="image5"></li>
<li>浏览器访问<!-- ![](/source/_posts/搭建个人博客/image6.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image6.png" class="" title="image6">
本地部署完成</li>
</ul>
</li>
<li>将Hexo部署到Github<ul>
<li>在Blog文件夹下找到_config.yml并打开，在文件末尾追加<!-- ![](/source/_posts/搭建个人博客/image7.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image7.png" class="" title="image7"></li>
<li>还是在Blog文件夹下打开Git Bash，安装git部署插件<!-- ![](/source/_posts/搭建个人博客/image8.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image8.png" class="" title="image8"></li>
<li>清理缓存并重新部署<!-- ![](/source/_posts/搭建个人博客/image9.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image9.png" class="" title="image9"></li>
<li>浏览器访问<!-- ![](/source/_posts/搭建个人博客/image11.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image11.png" class="" title="image11">
部署成功</li>
</ul>
</li>
<li>绑定域名<ul>
<li>从阿里云购买一个域名，在域名控制台点击“解析”<!-- ![](/source/_posts/搭建个人博客/image12.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image12.png" class="" title="image12"></li>
<li>添加两条记录，其中第一条记录值可以ping 仓库名得到<!-- ![](/source/_posts/搭建个人博客/image18.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image18.png" class="" title="image18">
<!-- ![](/source/_posts/搭建个人博客/image19.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image19.png" class="" title="image19"></li>
<li>在Blog\source下新建一个CNAME文件，写入购买的域名<!-- ![](/source/_posts/搭建个人博客/image14.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image14.png" class="" title="image14"></li>
<li>还是在Blog文件夹下，打开Git Bash，依次执行以下代码<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
<li>查看repo的setting-&gt;Pages,Custom domain已经配置好了<!-- ![](/source/_posts/搭建个人博客/image15.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image15.png" class="" title="image15">
<!-- ![](/source/_posts/搭建个人博客/image16.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image16.png" class="" title="image16"></li>
<li>直接访问该域名<!-- ![](/source/_posts/搭建个人博客/image17.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image17.png" class="" title="image17"></li>
</ul>
</li>
</ul>
<h1 id="部署到云服务器"><a href="#部署到云服务器" class="headerlink" title="部署到云服务器"></a>部署到云服务器</h1><p>可参考 <a href="https://cloud.tencent.com/developer/article/1662792">Hexo进阶教程（四）| 部署Hexo到自己的服务器</a></p>
<h1 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h1><ul>
<li>以Cactus主题为例<ul>
<li><a href="https://github.com/probberechts/hexo-theme-cactus?tab=readme-ov-file#install">Cactus官方使用文档</a></li>
<li>在Blog目录下打开Git Bash，执行git clone<!-- ![](/source/_posts/搭建个人博客/image22.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image22.png" class="" title="image22"></li>
<li>修改_config.yml<!-- ![](/source/_posts/搭建个人博客/image23.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image23.png" class="" title="image23"></li>
<li>进入&#x2F;theme&#x2F;cactus文件夹下，修改_config.yml,选择自己喜欢的scheme<!-- ![](/source/_posts/搭建个人博客/image25.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image25.png" class="" title="image25"></li>
<li>重新启动hexo<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
<li>博客页面的主题已经被成功切换<!-- ![](/source/_posts/搭建个人博客/image26.png) -->
<img src="/2024/05/24/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image26.png" class="" title="image26"></li>
<li>优化主题可参考<a href="https://zhuanlan.zhihu.com/p/106060640">个人博客第8篇——优化主题（持续更新）</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>experience</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
